<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api-documentation for
    <a
        
        href="http://github.com/shelljs/shelljs"
        
    >shelljs (v0.7.7)</a>
</h1>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>
    
    <li class="apidocModuleLi"><a href="#apidoc.module.shelljs">module shelljs</a><ol>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.ShellString">
            function <span class="apidocSignatureSpan">shelljs.</span>ShellString
            <span class="apidocSignatureSpan">(stdout, stderr, code)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.cat">
            function <span class="apidocSignatureSpan">shelljs.</span>cat
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.cd">
            function <span class="apidocSignatureSpan">shelljs.</span>cd
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.chmod">
            function <span class="apidocSignatureSpan">shelljs.</span>chmod
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.cp">
            function <span class="apidocSignatureSpan">shelljs.</span>cp
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.dirs">
            function <span class="apidocSignatureSpan">shelljs.</span>dirs
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.echo">
            function <span class="apidocSignatureSpan">shelljs.</span>echo
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.error">
            function <span class="apidocSignatureSpan">shelljs.</span>error
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.exec">
            function <span class="apidocSignatureSpan">shelljs.</span>exec
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.exit">
            function <span class="apidocSignatureSpan">shelljs.</span>exit
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.find">
            function <span class="apidocSignatureSpan">shelljs.</span>find
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.grep">
            function <span class="apidocSignatureSpan">shelljs.</span>grep
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.head">
            function <span class="apidocSignatureSpan">shelljs.</span>head
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.ln">
            function <span class="apidocSignatureSpan">shelljs.</span>ln
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.ls">
            function <span class="apidocSignatureSpan">shelljs.</span>ls
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.mkdir">
            function <span class="apidocSignatureSpan">shelljs.</span>mkdir
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.mv">
            function <span class="apidocSignatureSpan">shelljs.</span>mv
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.popd">
            function <span class="apidocSignatureSpan">shelljs.</span>popd
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.pushd">
            function <span class="apidocSignatureSpan">shelljs.</span>pushd
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.pwd">
            function <span class="apidocSignatureSpan">shelljs.</span>pwd
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.rm">
            function <span class="apidocSignatureSpan">shelljs.</span>rm
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.sed">
            function <span class="apidocSignatureSpan">shelljs.</span>sed
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.set">
            function <span class="apidocSignatureSpan">shelljs.</span>set
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.sort">
            function <span class="apidocSignatureSpan">shelljs.</span>sort
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.tail">
            function <span class="apidocSignatureSpan">shelljs.</span>tail
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.tempdir">
            function <span class="apidocSignatureSpan">shelljs.</span>tempdir
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.test">
            function <span class="apidocSignatureSpan">shelljs.</span>test
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.touch">
            function <span class="apidocSignatureSpan">shelljs.</span>touch
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.uniq">
            function <span class="apidocSignatureSpan">shelljs.</span>uniq
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.which">
            function <span class="apidocSignatureSpan">shelljs.</span>which
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">shelljs.</span>config</span>
            
        </li>
        
    </ol></li>
    
    <li class="apidocModuleLi"><a href="#apidoc.module.shelljs.config">module shelljs.config</a><ol>
        
        <li>
            
            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">shelljs.config.</span>fatal</span>
            
        </li>
        
        <li>
            
            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">shelljs.config.</span>noglob</span>
            
        </li>
        
        <li>
            
            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">shelljs.config.</span>silent</span>
            
        </li>
        
        <li>
            
            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">shelljs.config.</span>verbose</span>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.config.reset">
            function <span class="apidocSignatureSpan">shelljs.config.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.shelljs.config.resetForTesting">
            function <span class="apidocSignatureSpan">shelljs.config.</span>resetForTesting
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">shelljs.config.</span>maxdepth</span>
            
        </li>
        
        <li>
            
            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">shelljs.config.</span>globOptions</span>
            
        </li>
        
        <li>
            
            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">shelljs.config.</span>execPath</span>
            
        </li>
        
    </ol></li>
    
</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.shelljs" id="apidoc.module.shelljs">module shelljs</a></h1>
    
    
    <h2>
        <a href="#apidoc.element.shelljs.ShellString" id="apidoc.element.shelljs.ShellString">
        function <span class="apidocSignatureSpan">shelljs.</span>ShellString
        <span class="apidocSignatureSpan">(stdout, stderr, code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ShellString(stdout, stderr, code) {
  var that;
  if (stdout instanceof Array) {
    that = stdout;
    that.stdout = stdout.join(&#x27;\n&#x27;);
    if (stdout.length &#x3e; 0) that.stdout += &#x27;\n&#x27;;
  } else {
    that = new String(stdout);
    that.stdout = stdout;
  }
  that.stderr = stderr;
  that.code = code;
  // A list of all commands that can appear on the right-hand side of a pipe
  // (populated by calls to common.wrap())
  pipeMethods.forEach(function (cmd) {
    that[cmd] = shellMethods[cmd].bind(that);
  });
  return that;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.cat" id="apidoc.element.shelljs.cat">
        function <span class="apidocSignatureSpan">shelljs.</span>cat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cat = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
shell.cd(&#x27;lib&#x27;);
shell.ls(&#x27;*.js&#x27;).forEach(function (file) {
shell.sed(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
shell.sed(&#x27;-i&#x27;, /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.<span class="apidocCodeKeywordSpan">cat</span>(&#x27;macro.js&#\
x27;), file);
});
shell.cd(&#x27;..&#x27;);

// Run external tool synchronously
if (shell.exec(&#x27;git commit -am &#x22;Auto-commit&#x22;&#x27;).code !== 0) {
shell.echo(&#x27;Error: Git commit failed&#x27;);
shell.exit(1);
...</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.cd" id="apidoc.element.shelljs.cd">
        function <span class="apidocSignatureSpan">shelljs.</span>cd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cd = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
shell.<span class="apidocCodeKeywordSpan">cd</span>(&#x27;lib&#x27;);
shell.ls(&#x27;*.js&#x27;).forEach(function (file) {
  shell.sed(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat(&#x27;macro.js&#x27;), file);
});
shell.cd(&#x27;..&#x27;);
...</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.chmod" id="apidoc.element.shelljs.chmod">
        function <span class="apidocSignatureSpan">shelljs.</span>chmod
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chmod = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.cp" id="apidoc.element.shelljs.cp">
        function <span class="apidocSignatureSpan">shelljs.</span>cp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cp = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!shell.which(&#x27;git&#x27;)) {
shell.echo(&#x27;Sorry, this script requires git&#x27;);
shell.exit(1);
}

// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.<span class="apidocCodeKeywordSpan">cp</span>(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
shell.cd(&#x27;lib&#x27;);
shell.ls(&#x27;*.js&#x27;).forEach(function (file) {
shell.sed(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
shell.sed(&#x27;-i&#x27;, /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat(&#x27;macro.js&#x27;), file);
...</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.dirs" id="apidoc.element.shelljs.dirs">
        function <span class="apidocSignatureSpan">shelljs.</span>dirs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dirs = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.echo" id="apidoc.element.shelljs.echo">
        function <span class="apidocSignatureSpan">shelljs.</span>echo
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">echo = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Examples

```javascript
var shell = require(&#x27;shelljs&#x27;);

if (!shell.which(&#x27;git&#x27;)) {
  shell.<span class="apidocCodeKeywordSpan">echo</span>(&#x27;Sorry, this script requires git&#x27;);
  shell.exit(1);
}

// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);
...</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.error" id="apidoc.element.shelljs.error">
        function <span class="apidocSignatureSpan">shelljs.</span>error
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function error() {
  return common.state.error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.exec" id="apidoc.element.shelljs.exec">
        function <span class="apidocSignatureSpan">shelljs.</span>exec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  shell.sed(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat(&#x27;macro.js&#x27;), file);
});
shell.cd(&#x27;..&#x27;);

// Run external tool synchronously
if (shell.<span class="apidocCodeKeywordSpan">exec</span>(&#x27;git commit -am &#x22;Auto-commit&#x22;&#x27;).code !== 0) {
  shell.echo(&#x27;Error: Git commit failed&#x27;);
  shell.exit(1);
}
```

## Global vs. Local
...</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.exit" id="apidoc.element.shelljs.exit">
        function <span class="apidocSignatureSpan">shelljs.</span>exit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exit = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Examples

```javascript
var shell = require(&#x27;shelljs&#x27;);

if (!shell.which(&#x27;git&#x27;)) {
  shell.echo(&#x27;Sorry, this script requires git&#x27;);
  shell.<span class="apidocCodeKeywordSpan">exit</span>(1);
}

// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
...</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.find" id="apidoc.element.shelljs.find">
        function <span class="apidocSignatureSpan">shelljs.</span>find
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.grep" id="apidoc.element.shelljs.grep">
        function <span class="apidocSignatureSpan">shelljs.</span>grep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">grep = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### Pipes

Examples:

```javascript
grep(&#x27;foo&#x27;, &#x27;file1.txt&#x27;, &#x27;file2.txt&#x27;).sed(/o/g, &#x27;a&#x27;).to(&#x27;output.txt&#x27;);
echo(&#x27;files with o\&#x27;s in the name:\n&#x27; + ls().<span class="apidocCodeKeywordSpan">grep</span>(&#x27;o&#x27;));
cat(&#x27;test.js&#x27;).exec(&#x27;node&#x27;); // pipe to exec() call
```

Commands can send their output to another command in a pipe-like fashion.
`sed`, `grep`, `cat`, `exec`, `to`, and `toEnd` can appear on the right-hand
side of a pipe. Pipes can be chained.
...</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.head" id="apidoc.element.shelljs.head">
        function <span class="apidocSignatureSpan">shelljs.</span>head
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">head = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.ln" id="apidoc.element.shelljs.ln">
        function <span class="apidocSignatureSpan">shelljs.</span>ln
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ln = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.ls" id="apidoc.element.shelljs.ls">
        function <span class="apidocSignatureSpan">shelljs.</span>ls
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ls = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
shell.cd(&#x27;lib&#x27;);
shell.<span class="apidocCodeKeywordSpan">ls</span>(&#x27;*.js&#x27;).forEach(function (file) {
  shell.sed(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat(&#x27;macro.js&#x27;), file);
});
shell.cd(&#x27;..&#x27;);

// Run external tool synchronously
...</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.mkdir" id="apidoc.element.shelljs.mkdir">
        function <span class="apidocSignatureSpan">shelljs.</span>mkdir
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdir = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.mv" id="apidoc.element.shelljs.mv">
        function <span class="apidocSignatureSpan">shelljs.</span>mv
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mv = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.popd" id="apidoc.element.shelljs.popd">
        function <span class="apidocSignatureSpan">shelljs.</span>popd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">popd = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.pushd" id="apidoc.element.shelljs.pushd">
        function <span class="apidocSignatureSpan">shelljs.</span>pushd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pushd = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.pwd" id="apidoc.element.shelljs.pwd">
        function <span class="apidocSignatureSpan">shelljs.</span>pwd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pwd = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.rm" id="apidoc.element.shelljs.rm">
        function <span class="apidocSignatureSpan">shelljs.</span>rm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rm = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (!shell.which(&#x27;git&#x27;)) {
shell.echo(&#x27;Sorry, this script requires git&#x27;);
shell.exit(1);
}

// Copy files to release dir
shell.<span class="apidocCodeKeywordSpan">rm</span>(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
shell.cd(&#x27;lib&#x27;);
shell.ls(&#x27;*.js&#x27;).forEach(function (file) {
shell.sed(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
...</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.sed" id="apidoc.element.shelljs.sed">
        function <span class="apidocSignatureSpan">shelljs.</span>sed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sed = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
shell.cd(&#x27;lib&#x27;);
shell.ls(&#x27;*.js&#x27;).forEach(function (file) {
  shell.<span class="apidocCodeKeywordSpan">sed</span>(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat(&#x27;macro.js&#x27;), file);
});
shell.cd(&#x27;..&#x27;);

// Run external tool synchronously
if (shell.exec(&#x27;git commit -am &#x22;Auto-commit&#x22;&#x27;).code !== 0) {
...</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.set" id="apidoc.element.shelljs.set">
        function <span class="apidocSignatureSpan">shelljs.</span>set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.sort" id="apidoc.element.shelljs.sort">
        function <span class="apidocSignatureSpan">shelljs.</span>sort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sort = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.tail" id="apidoc.element.shelljs.tail">
        function <span class="apidocSignatureSpan">shelljs.</span>tail
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tail = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.tempdir" id="apidoc.element.shelljs.tempdir">
        function <span class="apidocSignatureSpan">shelljs.</span>tempdir
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tempdir = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.test" id="apidoc.element.shelljs.test">
        function <span class="apidocSignatureSpan">shelljs.</span>test
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">test = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.touch" id="apidoc.element.shelljs.touch">
        function <span class="apidocSignatureSpan">shelljs.</span>touch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">touch = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.uniq" id="apidoc.element.shelljs.uniq">
        function <span class="apidocSignatureSpan">shelljs.</span>uniq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uniq = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.which" id="apidoc.element.shelljs.which">
        function <span class="apidocSignatureSpan">shelljs.</span>which
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">which = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

## Examples

```javascript
var shell = require(&#x27;shelljs&#x27;);

if (!shell.<span class="apidocCodeKeywordSpan">which</span>(&#x27;git&#x27;)) {
  shell.echo(&#x27;Sorry, this script requires git&#x27;);
  shell.exit(1);
}

// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);
...</pre></li>
    </ul>
    
    
    
    
</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.shelljs.config" id="apidoc.module.shelljs.config">module shelljs.config</a></h1>
    
    
    
    
    
    
    
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.config.reset" id="apidoc.element.shelljs.config.reset">
        function <span class="apidocSignatureSpan">shelljs.config.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
  objectAssign(this, DEFAULT_CONFIG);
  if (!isElectron) {
    this.execPath = process.execPath;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
config.globOptions = {nodir: true};
```

Use this value for calls to `glob.sync()` instead of the default options.

### config.<span class="apidocCodeKeywordSpan">reset</span>()

Example:

```javascript
var shell = require(&#x27;shelljs&#x27;);
// Make changes to shell.config, and do stuff...
/* ... */
...</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.shelljs.config.resetForTesting" id="apidoc.element.shelljs.config.resetForTesting">
        function <span class="apidocSignatureSpan">shelljs.config.</span>resetForTesting
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resetForTesting = function () {
  this.reset();
  this.silent = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    
    
    
    
    
</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
