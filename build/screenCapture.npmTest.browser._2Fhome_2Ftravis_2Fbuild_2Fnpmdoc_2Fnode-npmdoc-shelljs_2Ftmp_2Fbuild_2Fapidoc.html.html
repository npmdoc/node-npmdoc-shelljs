<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://github.com/shelljs/shelljs">shelljs (v0.7.7)</a>
</h1>
<h4>Portable Unix shell commands for Node.js</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.shelljs">module shelljs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.ShellString">
            function <span class="apidocSignatureSpan">shelljs.</span>ShellString
            <span class="apidocSignatureSpan">(stdout, stderr, code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.cat">
            function <span class="apidocSignatureSpan">shelljs.</span>cat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.cd">
            function <span class="apidocSignatureSpan">shelljs.</span>cd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.chmod">
            function <span class="apidocSignatureSpan">shelljs.</span>chmod
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.cp">
            function <span class="apidocSignatureSpan">shelljs.</span>cp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.dirs">
            function <span class="apidocSignatureSpan">shelljs.</span>dirs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.echo">
            function <span class="apidocSignatureSpan">shelljs.</span>echo
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.error">
            function <span class="apidocSignatureSpan">shelljs.</span>error
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.exec">
            function <span class="apidocSignatureSpan">shelljs.</span>exec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.exit">
            function <span class="apidocSignatureSpan">shelljs.</span>exit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.find">
            function <span class="apidocSignatureSpan">shelljs.</span>find
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.grep">
            function <span class="apidocSignatureSpan">shelljs.</span>grep
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.head">
            function <span class="apidocSignatureSpan">shelljs.</span>head
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.ln">
            function <span class="apidocSignatureSpan">shelljs.</span>ln
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.ls">
            function <span class="apidocSignatureSpan">shelljs.</span>ls
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.mkdir">
            function <span class="apidocSignatureSpan">shelljs.</span>mkdir
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.mv">
            function <span class="apidocSignatureSpan">shelljs.</span>mv
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.popd">
            function <span class="apidocSignatureSpan">shelljs.</span>popd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.pushd">
            function <span class="apidocSignatureSpan">shelljs.</span>pushd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.pwd">
            function <span class="apidocSignatureSpan">shelljs.</span>pwd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.rm">
            function <span class="apidocSignatureSpan">shelljs.</span>rm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.sed">
            function <span class="apidocSignatureSpan">shelljs.</span>sed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.set">
            function <span class="apidocSignatureSpan">shelljs.</span>set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.sort">
            function <span class="apidocSignatureSpan">shelljs.</span>sort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.tail">
            function <span class="apidocSignatureSpan">shelljs.</span>tail
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.tempdir">
            function <span class="apidocSignatureSpan">shelljs.</span>tempdir
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.test">
            function <span class="apidocSignatureSpan">shelljs.</span>test
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.touch">
            function <span class="apidocSignatureSpan">shelljs.</span>touch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.uniq">
            function <span class="apidocSignatureSpan">shelljs.</span>uniq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.which">
            function <span class="apidocSignatureSpan">shelljs.</span>which
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">shelljs.</span>common</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">shelljs.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">shelljs.</span>plugin</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.shelljs.common">module shelljs.common</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.ShellString">
            function <span class="apidocSignatureSpan">shelljs.common.</span>ShellString
            <span class="apidocSignatureSpan">(stdout, stderr, code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.convertErrorOutput">
            function <span class="apidocSignatureSpan">shelljs.common.</span>convertErrorOutput
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.error">
            function <span class="apidocSignatureSpan">shelljs.common.</span>error
            <span class="apidocSignatureSpan">(msg, _code, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.expand">
            function <span class="apidocSignatureSpan">shelljs.common.</span>expand
            <span class="apidocSignatureSpan">(list)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.extend">
            function <span class="apidocSignatureSpan">shelljs.common.</span>extend
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.getUserHome">
            function <span class="apidocSignatureSpan">shelljs.common.</span>getUserHome
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.isObject">
            function <span class="apidocSignatureSpan">shelljs.common.</span>isObject
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.log">
            function <span class="apidocSignatureSpan">shelljs.common.</span>log
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.parseOptions">
            function <span class="apidocSignatureSpan">shelljs.common.</span>parseOptions
            <span class="apidocSignatureSpan">(opt, map, errorOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.randomFileName">
            function <span class="apidocSignatureSpan">shelljs.common.</span>randomFileName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.readFromPipe">
            function <span class="apidocSignatureSpan">shelljs.common.</span>readFromPipe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.register">
            function <span class="apidocSignatureSpan">shelljs.common.</span>register
            <span class="apidocSignatureSpan">(name, implementation, wrapOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.unlinkSync">
            function <span class="apidocSignatureSpan">shelljs.common.</span>unlinkSync
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.wrap">
            function <span class="apidocSignatureSpan">shelljs.common.</span>wrap
            <span class="apidocSignatureSpan">(cmd, fn, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">shelljs.common.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">shelljs.common.</span>state</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">shelljs.common.</span>platform</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.shelljs.config">module shelljs.config</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">shelljs.config.</span>fatal</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">shelljs.config.</span>noglob</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">shelljs.config.</span>silent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">shelljs.config.</span>verbose</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.config.reset">
            function <span class="apidocSignatureSpan">shelljs.config.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.config.resetForTesting">
            function <span class="apidocSignatureSpan">shelljs.config.</span>resetForTesting
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">shelljs.config.</span>maxdepth</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">shelljs.config.</span>globOptions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">shelljs.config.</span>execPath</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.shelljs.dirs">module shelljs.dirs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.dirs.dirs">
            function <span class="apidocSignatureSpan">shelljs.</span>dirs
            <span class="apidocSignatureSpan">(options, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.dirs.popd">
            function <span class="apidocSignatureSpan">shelljs.dirs.</span>popd
            <span class="apidocSignatureSpan">(options, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.dirs.pushd">
            function <span class="apidocSignatureSpan">shelljs.dirs.</span>pushd
            <span class="apidocSignatureSpan">(options, dir)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.shelljs.plugin">module shelljs.plugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.plugin.error">
            function <span class="apidocSignatureSpan">shelljs.plugin.</span>error
            <span class="apidocSignatureSpan">(msg, _code, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.plugin.parseOptions">
            function <span class="apidocSignatureSpan">shelljs.plugin.</span>parseOptions
            <span class="apidocSignatureSpan">(opt, map, errorOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.plugin.readFromPipe">
            function <span class="apidocSignatureSpan">shelljs.plugin.</span>readFromPipe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.plugin.register">
            function <span class="apidocSignatureSpan">shelljs.plugin.</span>register
            <span class="apidocSignatureSpan">(name, implementation, wrapOptions)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.shelljs" id="apidoc.module.shelljs">module shelljs</a></h1>


    <h2>
        <a href="#apidoc.element.shelljs.ShellString" id="apidoc.element.shelljs.ShellString">
        function <span class="apidocSignatureSpan">shelljs.</span>ShellString
        <span class="apidocSignatureSpan">(stdout, stderr, code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ShellString(stdout, stderr, code) {
  var that;
  if (stdout instanceof Array) {
    that = stdout;
    that.stdout = stdout.join('\n');
    if (stdout.length &gt; 0) that.stdout += '\n';
  } else {
    that = new String(stdout);
    that.stdout = stdout;
  }
  that.stderr = stderr;
  that.code = code;
  // A list of all commands that can appear on the right-hand side of a pipe
  // (populated by calls to common.wrap())
  pipeMethods.forEach(function (cmd) {
    that[cmd] = shellMethods[cmd].bind(that);
  });
  return that;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Dest is not existing dir, but multiple sources given
if ((!destExists || !destStat.isDirectory()) &amp;&amp; sources.length &gt; 1) {
  common.error('dest is not a directory (too many sources)');
}

// Dest is an existing file, but -n is given
if (destExists &amp;&amp; destStat.isFile() &amp;&amp; options.no_force) {
  return new common.<span class="apidocCodeKeywordSpan">ShellString</span>('', '', 0);
}

sources.forEach(function (src) {
  if (!fs.existsSync(src)) {
    common.error('no such file or directory: ' + src, { continue: true });
    return; // skip file
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.cat" id="apidoc.element.shelljs.cat">
        function <span class="apidocSignatureSpan">shelljs.</span>cat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cat = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
shell.cp('-R', 'stuff/', 'out/Release');

// Replace macros in each .js file
shell.cd('lib');
shell.ls('*.js').forEach(function (file) {
shell.sed('-i', 'BUILD_VERSION', 'v0.1.2', file);
shell.sed('-i', /^.*REMOVE_THIS_LINE.*$/, '', file);
shell.sed('-i', /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.<span class="apidocCodeKeywordSpan">cat</span>('macro.js&amp;#
x27;), file);
});
shell.cd('..');

// Run external tool synchronously
if (shell.exec('git commit -am "Auto-commit"').code !== 0) {
shell.echo('Error: Git commit failed');
shell.exit(1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.cd" id="apidoc.element.shelljs.cd">
        function <span class="apidocSignatureSpan">shelljs.</span>cd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cd = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Copy files to release dir
shell.rm('-rf', 'out/Release');
shell.cp('-R', 'stuff/', 'out/Release');

// Replace macros in each .js file
shell.<span class="apidocCodeKeywordSpan">cd</span>('lib');
shell.ls('*.js').forEach(function (file) {
  shell.sed('-i', 'BUILD_VERSION', 'v0.1.2', file);
  shell.sed('-i', /^.*REMOVE_THIS_LINE.*$/, '', file);
  shell.sed('-i', /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat('macro.js'), file);
});
shell.cd('..');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.chmod" id="apidoc.element.shelljs.chmod">
        function <span class="apidocSignatureSpan">shelljs.</span>chmod
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chmod = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.cp" id="apidoc.element.shelljs.cp">
        function <span class="apidocSignatureSpan">shelljs.</span>cp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cp = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!shell.which('git')) {
shell.echo('Sorry, this script requires git');
shell.exit(1);
}

// Copy files to release dir
shell.rm('-rf', 'out/Release');
shell.<span class="apidocCodeKeywordSpan">cp</span>('-R', 'stuff/', 'out/Release');

// Replace macros in each .js file
shell.cd('lib');
shell.ls('*.js').forEach(function (file) {
shell.sed('-i', 'BUILD_VERSION', 'v0.1.2', file);
shell.sed('-i', /^.*REMOVE_THIS_LINE.*$/, '', file);
shell.sed('-i', /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat('macro.js'), file);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.dirs" id="apidoc.element.shelljs.dirs">
        function <span class="apidocSignatureSpan">shelljs.</span>dirs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dirs = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.echo" id="apidoc.element.shelljs.echo">
        function <span class="apidocSignatureSpan">shelljs.</span>echo
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">echo = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Examples

```javascript
var shell = require('shelljs');

if (!shell.which('git')) {
  shell.<span class="apidocCodeKeywordSpan">echo</span>('Sorry, this script requires git');
  shell.exit(1);
}

// Copy files to release dir
shell.rm('-rf', 'out/Release');
shell.cp('-R', 'stuff/', 'out/Release');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.error" id="apidoc.element.shelljs.error">
        function <span class="apidocSignatureSpan">shelljs.</span>error
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function error() {
  return common.state.error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//@
//@ Returns a string containing the given file, or a concatenated string
//@ containing the files if more than one file is given (a new line character is
//@ introduced between each file).
function _cat(options, files) {
var cat = common.readFromPipe();

if (!files &amp;&amp; !cat) common.<span class="apidocCodeKeywordSpan">error</span>('no paths given');

files = [].slice.call(arguments, 1);

files.forEach(function (file) {
  if (!fs.existsSync(file)) {
    common.error('no such file or directory: ' + file);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.exec" id="apidoc.element.shelljs.exec">
        function <span class="apidocSignatureSpan">shelljs.</span>exec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  shell.sed('-i', 'BUILD_VERSION', 'v0.1.2', file);
  shell.sed('-i', /^.*REMOVE_THIS_LINE.*$/, '', file);
  shell.sed('-i', /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat('macro.js'), file);
});
shell.cd('..');

// Run external tool synchronously
if (shell.<span class="apidocCodeKeywordSpan">exec</span>('git commit -am "Auto-commit"').code !== 0) {
  shell.echo('Error: Git commit failed');
  shell.exit(1);
}
```

## Global vs. Local
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.exit" id="apidoc.element.shelljs.exit">
        function <span class="apidocSignatureSpan">shelljs.</span>exit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exit = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Examples

```javascript
var shell = require('shelljs');

if (!shell.which('git')) {
  shell.echo('Sorry, this script requires git');
  shell.<span class="apidocCodeKeywordSpan">exit</span>(1);
}

// Copy files to release dir
shell.rm('-rf', 'out/Release');
shell.cp('-R', 'stuff/', 'out/Release');

// Replace macros in each .js file
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.find" id="apidoc.element.shelljs.find">
        function <span class="apidocSignatureSpan">shelljs.</span>find
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.grep" id="apidoc.element.shelljs.grep">
        function <span class="apidocSignatureSpan">shelljs.</span>grep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">grep = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### Pipes

Examples:

```javascript
grep('foo', 'file1.txt', 'file2.txt').sed(/o/g, 'a').to('output.txt');
echo('files with o\'s in the name:\n' + ls().<span class="apidocCodeKeywordSpan">grep</span>('o'));
cat('test.js').exec('node'); // pipe to exec() call
```

Commands can send their output to another command in a pipe-like fashion.
`sed`, `grep`, `cat`, `exec`, `to`, and `toEnd` can appear on the right-hand
side of a pipe. Pipes can be chained.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.head" id="apidoc.element.shelljs.head">
        function <span class="apidocSignatureSpan">shelljs.</span>head
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">head = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.ln" id="apidoc.element.shelljs.ln">
        function <span class="apidocSignatureSpan">shelljs.</span>ln
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ln = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.ls" id="apidoc.element.shelljs.ls">
        function <span class="apidocSignatureSpan">shelljs.</span>ls
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ls = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Copy files to release dir
shell.rm('-rf', 'out/Release');
shell.cp('-R', 'stuff/', 'out/Release');

// Replace macros in each .js file
shell.cd('lib');
shell.<span class="apidocCodeKeywordSpan">ls</span>('*.js').forEach(function (file) {
  shell.sed('-i', 'BUILD_VERSION', 'v0.1.2', file);
  shell.sed('-i', /^.*REMOVE_THIS_LINE.*$/, '', file);
  shell.sed('-i', /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat('macro.js'), file);
});
shell.cd('..');

// Run external tool synchronously
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.mkdir" id="apidoc.element.shelljs.mkdir">
        function <span class="apidocSignatureSpan">shelljs.</span>mkdir
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdir = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.mv" id="apidoc.element.shelljs.mv">
        function <span class="apidocSignatureSpan">shelljs.</span>mv
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mv = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.popd" id="apidoc.element.shelljs.popd">
        function <span class="apidocSignatureSpan">shelljs.</span>popd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">popd = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.pushd" id="apidoc.element.shelljs.pushd">
        function <span class="apidocSignatureSpan">shelljs.</span>pushd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pushd = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.pwd" id="apidoc.element.shelljs.pwd">
        function <span class="apidocSignatureSpan">shelljs.</span>pwd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pwd = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.rm" id="apidoc.element.shelljs.rm">
        function <span class="apidocSignatureSpan">shelljs.</span>rm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rm = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (!shell.which('git')) {
shell.echo('Sorry, this script requires git');
shell.exit(1);
}

// Copy files to release dir
shell.<span class="apidocCodeKeywordSpan">rm</span>('-rf', 'out/Release');
shell.cp('-R', 'stuff/', 'out/Release');

// Replace macros in each .js file
shell.cd('lib');
shell.ls('*.js').forEach(function (file) {
shell.sed('-i', 'BUILD_VERSION', 'v0.1.2', file);
shell.sed('-i', /^.*REMOVE_THIS_LINE.*$/, '', file);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.sed" id="apidoc.element.shelljs.sed">
        function <span class="apidocSignatureSpan">shelljs.</span>sed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sed = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Copy files to release dir
shell.rm('-rf', 'out/Release');
shell.cp('-R', 'stuff/', 'out/Release');

// Replace macros in each .js file
shell.cd('lib');
shell.ls('*.js').forEach(function (file) {
  shell.<span class="apidocCodeKeywordSpan">sed</span>('-i', 'BUILD_VERSION', 'v0.1.2', file);
  shell.sed('-i', /^.*REMOVE_THIS_LINE.*$/, '', file);
  shell.sed('-i', /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat('macro.js'), file);
});
shell.cd('..');

// Run external tool synchronously
if (shell.exec('git commit -am "Auto-commit"').code !== 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.set" id="apidoc.element.shelljs.set">
        function <span class="apidocSignatureSpan">shelljs.</span>set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.sort" id="apidoc.element.shelljs.sort">
        function <span class="apidocSignatureSpan">shelljs.</span>sort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sort = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    var contents = file === '-' ? pipe : fs.readFileSync(file, 'utf8');
    lines = lines.concat(contents.trimRight().split(/\r*\n/));
  });

  var sorted;
  sorted = lines.<span class="apidocCodeKeywordSpan">sort</span>(options.numerical ? numericalCmp : unixCmp);

  if (options.reverse) {
    sorted = sorted.reverse();
  }

  return sorted.join('\n') + '\n';
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.tail" id="apidoc.element.shelljs.tail">
        function <span class="apidocSignatureSpan">shelljs.</span>tail
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tail = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.tempdir" id="apidoc.element.shelljs.tempdir">
        function <span class="apidocSignatureSpan">shelljs.</span>tempdir
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tempdir = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.test" id="apidoc.element.shelljs.test">
        function <span class="apidocSignatureSpan">shelljs.</span>test
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">test = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    //   $ cd ../../../..
    //   $ cp -RL 1 copy
    var cyclecheck = fs.statSync(srcFile);
    if (cyclecheck.isDirectory()) {
      var sourcerealpath = fs.realpathSync(sourceDir);
      var symlinkrealpath = fs.realpathSync(srcFile);
      var re = new RegExp(symlinkrealpath);
      if (re.<span class="apidocCodeKeywordSpan">test</span>(sourcerealpath)) {
        return true;
      }
    }
  }
  return false;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.touch" id="apidoc.element.shelljs.touch">
        function <span class="apidocSignatureSpan">shelljs.</span>touch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">touch = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.uniq" id="apidoc.element.shelljs.uniq">
        function <span class="apidocSignatureSpan">shelljs.</span>uniq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uniq = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.which" id="apidoc.element.shelljs.which">
        function <span class="apidocSignatureSpan">shelljs.</span>which
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">which = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let's set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
        // a no-op, allowing the syntax `touch({'-r': file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
        args.unshift(''); // only add dummy option if '-option' not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
          return arg.toString();
        }
        return arg;
      });

      // Expand the '~' if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === 'earlyExit') {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
      console.error('ShellJS: internal error');
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &amp;&amp;
      (typeof retValue === 'string' || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = 'shell.js';
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

## Examples

```javascript
var shell = require('shelljs');

if (!shell.<span class="apidocCodeKeywordSpan">which</span>('git')) {
  shell.echo('Sorry, this script requires git');
  shell.exit(1);
}

// Copy files to release dir
shell.rm('-rf', 'out/Release');
shell.cp('-R', 'stuff/', 'out/Release');
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.shelljs.common" id="apidoc.module.shelljs.common">module shelljs.common</a></h1>


    <h2>
        <a href="#apidoc.element.shelljs.common.ShellString" id="apidoc.element.shelljs.common.ShellString">
        function <span class="apidocSignatureSpan">shelljs.common.</span>ShellString
        <span class="apidocSignatureSpan">(stdout, stderr, code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ShellString(stdout, stderr, code) {
  var that;
  if (stdout instanceof Array) {
    that = stdout;
    that.stdout = stdout.join('\n');
    if (stdout.length &gt; 0) that.stdout += '\n';
  } else {
    that = new String(stdout);
    that.stdout = stdout;
  }
  that.stderr = stderr;
  that.code = code;
  // A list of all commands that can appear on the right-hand side of a pipe
  // (populated by calls to common.wrap())
  pipeMethods.forEach(function (cmd) {
    that[cmd] = shellMethods[cmd].bind(that);
  });
  return that;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Dest is not existing dir, but multiple sources given
if ((!destExists || !destStat.isDirectory()) &amp;&amp; sources.length &gt; 1) {
  common.error('dest is not a directory (too many sources)');
}

// Dest is an existing file, but -n is given
if (destExists &amp;&amp; destStat.isFile() &amp;&amp; options.no_force) {
  return new common.<span class="apidocCodeKeywordSpan">ShellString</span>('', '', 0);
}

sources.forEach(function (src) {
  if (!fs.existsSync(src)) {
    common.error('no such file or directory: ' + src, { continue: true });
    return; // skip file
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.convertErrorOutput" id="apidoc.element.shelljs.common.convertErrorOutput">
        function <span class="apidocSignatureSpan">shelljs.common.</span>convertErrorOutput
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertErrorOutput(msg) {
  if (typeof msg !== 'string') {
    throw new TypeError('input must be a string');
  }
  return msg.replace(/\\/g, '/');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.error" id="apidoc.element.shelljs.common.error">
        function <span class="apidocSignatureSpan">shelljs.common.</span>error
        <span class="apidocSignatureSpan">(msg, _code, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function error(msg, _code, options) {
  // Validate input
  if (typeof msg !== 'string') throw new Error('msg must be a string');

  var DEFAULT_OPTIONS = {
    continue: false,
    code: 1,
    prefix: state.currentCmd + ': ',
    silent: false,
  };

  if (typeof _code === 'number' &amp;&amp; isObject(options)) {
    options.code = _code;
  } else if (isObject(_code)) { // no 'code'
    options = _code;
  } else if (typeof _code === 'number') { // no 'options'
    options = { code: _code };
  } else if (typeof _code !== 'number') { // only 'msg'
    options = {};
  }
  options = objectAssign({}, DEFAULT_OPTIONS, options);

  if (!state.errorCode) state.errorCode = options.code;

  var logEntry = convertErrorOutput(options.prefix + msg);
  state.error = state.error ? state.error + '\n' : '';
  state.error += logEntry;

  // Throw an error, or log the entry
  if (config.fatal) throw new Error(logEntry);
  if (msg.length &gt; 0 &amp;&amp; !options.silent) log(logEntry);

  if (!options.continue) {
    throw {
      msg: 'earlyExit',
      retValue: (new ShellString('', state.error, state.errorCode)),
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//@
//@ Returns a string containing the given file, or a concatenated string
//@ containing the files if more than one file is given (a new line character is
//@ introduced between each file).
function _cat(options, files) {
var cat = common.readFromPipe();

if (!files &amp;&amp; !cat) common.<span class="apidocCodeKeywordSpan">error</span>('no paths given');

files = [].slice.call(arguments, 1);

files.forEach(function (file) {
  if (!fs.existsSync(file)) {
    common.error('no such file or directory: ' + file);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.expand" id="apidoc.element.shelljs.common.expand">
        function <span class="apidocSignatureSpan">shelljs.common.</span>expand
        <span class="apidocSignatureSpan">(list)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function expand(list) {
  if (!Array.isArray(list)) {
    throw new TypeError('must be an array');
  }
  var expanded = [];
  list.forEach(function (listEl) {
    // Don't expand non-strings
    if (typeof listEl !== 'string') {
      expanded.push(listEl);
    } else {
      var ret = glob.sync(listEl, config.globOptions);
      // if glob fails, interpret the string literally
      expanded = expanded.concat(ret.length &gt; 0 ? ret : [listEl]);
    }
  });
  return expanded;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'v': 'verbose',
  });

  filePattern = [].slice.call(arguments, 2);

  var files;

  // TODO: replace this with a call to common.<span class="apidocCodeKeywordSpan">expand</span>()
  if (options.recursive) {
    files = [];
    filePattern.forEach(function addFile(expandedFile) {
var stat = fs.lstatSync(expandedFile);

if (!stat.isSymbolicLink()) {
  files.push(expandedFile);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.extend" id="apidoc.element.shelljs.common.extend">
        function <span class="apidocSignatureSpan">shelljs.common.</span>extend
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function assign() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var tempDir = _tempDir();
var stdoutFile = path.resolve(tempDir + '/' + common.randomFileName());
var stderrFile = path.resolve(tempDir + '/' + common.randomFileName());
var codeFile = path.resolve(tempDir + '/' + common.randomFileName());
var scriptFile = path.resolve(tempDir + '/' + common.randomFileName());
var sleepFile = path.resolve(tempDir + '/' + common.randomFileName());

opts = common.<span class="apidocCodeKeywordSpan">extend</span>({
  silent: common.config.silent,
  cwd: _pwd().toString(),
  env: process.env,
  maxBuffer: DEFAULT_MAXBUFFER_SIZE,
}, opts);

var previousStdoutContent = '';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.getUserHome" id="apidoc.element.shelljs.common.getUserHome">
        function <span class="apidocSignatureSpan">shelljs.common.</span>getUserHome
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getUserHome() {
  var result;
  if (os.homedir) {
    result = os.homedir(); // node 3+
  } else {
    result = process.env[(process.platform === 'win32') ? 'USERPROFILE' : 'HOME'];
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
common.register('cd', _cd, {});

//@
//@ ### cd([dir])
//@ Changes to directory `dir` for the duration of the script. Changes to home
//@ directory if no argument is supplied.
function _cd(options, dir) {
if (!dir) dir = common.<span class="apidocCodeKeywordSpan">getUserHome</span>();

if (dir === '-') {
  if (!process.env.OLDPWD) {
    common.error('could not find previous directory');
  } else {
    dir = process.env.OLDPWD;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.isObject" id="apidoc.element.shelljs.common.isObject">
        function <span class="apidocSignatureSpan">shelljs.common.</span>isObject
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObject(a) {
  return typeof a === 'object' &amp;&amp; a !== null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.log" id="apidoc.element.shelljs.common.log">
        function <span class="apidocSignatureSpan">shelljs.common.</span>log
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log() {
<span class="apidocCodeCommentSpan">  /* istanbul ignore next */
</span>  if (!config.silent) {
    console.error.apply(console, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var child = exec('some_long_running_process', {async:true});
child.stdout.on('data', function(data) {
  /* ... do something with data ... */
});

exec('some_long_running_process', function(code, stdout, stderr) {
  console.<span class="apidocCodeKeywordSpan">log</span>('Exit code:', code);
  console.log('Program output:', stdout);
  console.log('Program stderr:', stderr);
});
```

Executes the given `command` _synchronously_, unless otherwise specified.  When in synchronous
mode, this returns a ShellString (compatible with ShellJS v0.6.x, which returns an object
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.parseOptions" id="apidoc.element.shelljs.common.parseOptions">
        function <span class="apidocSignatureSpan">shelljs.common.</span>parseOptions
        <span class="apidocSignatureSpan">(opt, map, errorOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseOptions(opt, map, errorOptions) {
  // Validate input
  if (typeof opt !== 'string' &amp;&amp; !isObject(opt)) {
    throw new Error('options must be strings or key-value pairs');
  } else if (!isObject(map)) {
    throw new Error('parseOptions() internal error: map must be an object');
  } else if (errorOptions &amp;&amp; !isObject(errorOptions)) {
    throw new Error('parseOptions() internal error: errorOptions must be object');
  }

  // All options are false by default
  var options = {};
  Object.keys(map).forEach(function (letter) {
    var optName = map[letter];
    if (optName[0] !== '!') {
      options[optName] = false;
    }
  });

  if (opt === '') return options; // defaults

  if (typeof opt === 'string') {
    if (opt[0] !== '-') {
      error("Options string must start with a '-'", errorOptions || {});
    }

    // e.g. chars = ['R', 'f']
    var chars = opt.slice(1).split('');

    chars.forEach(function (c) {
      if (c in map) {
        var optionName = map[c];
        if (optionName[0] === '!') {
          options[optionName.slice(1)] = false;
        } else {
          options[optionName] = true;
        }
      } else {
        error('option not recognized: ' + c, errorOptions || {});
      }
    });
  } else { // opt is an Object
    Object.keys(opt).forEach(function (key) {
      // key is a string of the form '-r', '-d', etc.
      var c = key[1];
      if (c in map) {
        var optionName = map[c];
        options[optionName] = opt[key]; // assign the given value
      } else {
        error('option not recognized: ' + c, errorOptions || {});
      }
    });
  }
  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // If we are down by one argument and options starts with -, shift everything over.
    [].unshift.call(arguments, '');
  } else {
    common.error('You must specify a file.');
  }
}

options = common.<span class="apidocCodeKeywordSpan">parseOptions</span>(options, {
  'R': 'recursive',
  'c': 'changes',
  'v': 'verbose',
});

filePattern = [].slice.call(arguments, 2);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.randomFileName" id="apidoc.element.shelljs.common.randomFileName">
        function <span class="apidocSignatureSpan">shelljs.common.</span>randomFileName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function randomFileName() {
  function randomHash(count) {
    if (count === 1) {
      return parseInt(16 * Math.random(), 10).toString(16);
    }
    var hash = '';
    for (var i = 0; i &lt; count; i++) {
      hash += randomHash(1);
    }
    return hash;
  }

  return 'shelljs_' + randomHash(20);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// event loop).
function execSync(cmd, opts, pipe) {
if (!common.config.execPath) {
  common.error('Unable to find a path to the node binary. Please manually set config.execPath');
}

var tempDir = _tempDir();
var stdoutFile = path.resolve(tempDir + '/' + common.<span class="apidocCodeKeywordSpan">randomFileName</span>());
var stderrFile = path.resolve(tempDir + '/' + common.randomFileName());
var codeFile = path.resolve(tempDir + '/' + common.randomFileName());
var scriptFile = path.resolve(tempDir + '/' + common.randomFileName());
var sleepFile = path.resolve(tempDir + '/' + common.randomFileName());

opts = common.extend({
  silent: common.config.silent,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.readFromPipe" id="apidoc.element.shelljs.common.readFromPipe">
        function <span class="apidocSignatureSpan">shelljs.common.</span>readFromPipe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _readFromPipe() {
  return state.pipedValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//@ var str = cat(['file1', 'file2']); // same as above
//@ ```
//@
//@ Returns a string containing the given file, or a concatenated string
//@ containing the files if more than one file is given (a new line character is
//@ introduced between each file).
function _cat(options, files) {
var cat = common.<span class="apidocCodeKeywordSpan">readFromPipe</span>();

if (!files &amp;&amp; !cat) common.error('no paths given');

files = [].slice.call(arguments, 1);

files.forEach(function (file) {
  if (!fs.existsSync(file)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.register" id="apidoc.element.shelljs.common.register">
        function <span class="apidocSignatureSpan">shelljs.common.</span>register
        <span class="apidocSignatureSpan">(name, implementation, wrapOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _register(name, implementation, wrapOptions) {
  wrapOptions = wrapOptions || {};
  // If an option isn't specified, use the default
  wrapOptions = objectAssign({}, DEFAULT_WRAP_OPTIONS, wrapOptions);

  if (shell[name] &amp;&amp; !wrapOptions.overWrite) {
    throw new Error('unable to overwrite `' + name + '` command');
  }

  if (wrapOptions.pipeOnly) {
    wrapOptions.canReceivePipe = true;
    shellMethods[name] = wrap(name, implementation, wrapOptions);
  } else {
    shell[name] = wrap(name, implementation, wrapOptions);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...




var common = require('./common');
var fs = require('fs');

common.<span class="apidocCodeKeywordSpan">register</span>('cat', _cat, {
  canReceivePipe: true,
});

//@
//@ ### cat(file [, file ...])
//@ ### cat(file_array)
//@
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.unlinkSync" id="apidoc.element.shelljs.common.unlinkSync">
        function <span class="apidocSignatureSpan">shelljs.common.</span>unlinkSync
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unlinkSync(file) {
  try {
    fs.unlinkSync(file);
  } catch (e) {
    // Try to override file permission
<span class="apidocCodeCommentSpan">    /* istanbul ignore next */
</span>    if (e.code === 'EPERM') {
      fs.chmodSync(file, '0666');
      fs.unlinkSync(file);
    } else {
      throw e;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
exports.expand = expand;

// Normalizes _unlinkSync() across platforms to match Unix behavior, i.e.
// file can be unlinked even if it's read-only, see https://github.com/joyent/node/issues/3006
function unlinkSync(file) {
try {
  fs.<span class="apidocCodeKeywordSpan">unlinkSync</span>(file);
} catch (e) {
  // Try to override file permission
  /* istanbul ignore next */
  if (e.code === 'EPERM') {
    fs.chmodSync(file, '0666');
    fs.unlinkSync(file);
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.wrap" id="apidoc.element.shelljs.common.wrap">
        function <span class="apidocSignatureSpan">shelljs.common.</span>wrap
        <span class="apidocSignatureSpan">(cmd, fn, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrap(cmd, fn, options) {
  options = options || {};
  if (options.canReceivePipe) {
    pipeMethods.push(cmd);
  }
  return function () {
    var retValue = null;

    state.currentCmd = cmd;
    state.error = null;
    state.errorCode = 0;

    try {
      var args = [].slice.call(arguments, 0);

      // Log the command to stderr, if appropriate
      if (config.verbose) {
        console.error.apply(console, [cmd].concat(args));
      }

      // If this is coming from a pipe, let's set the pipedValue (otherwise, set
      // it to the empty string)
      state.pipedValue = (this &amp;&amp; typeof this.stdout === 'string') ? this.stdout : '';

      if (options.unix === false) { // this branch is for exec()
        retValue = fn.apply(this, args);
      } else { // and this branch is for everything else
        if (isObject(args[0]) &amp;&amp; args[0].constructor.name === 'Object') {
          // a no-op, allowing the syntax `touch({'-r': file}, ...)`
        } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length &lt;= 1 || args[0][0] !== '-') {
          args.unshift(''); // only add dummy option if '-option' not already present
        }

        // flatten out arrays that are arguments, to make the syntax:
        //    `cp([file1, file2, file3], dest);`
        // equivalent to:
        //    `cp(file1, file2, file3, dest);`
        args = args.reduce(function (accum, cur) {
          if (Array.isArray(cur)) {
            return accum.concat(cur);
          }
          accum.push(cur);
          return accum;
        }, []);

        // Convert ShellStrings (basically just String objects) to regular strings
        args = args.map(function (arg) {
          if (isObject(arg) &amp;&amp; arg.constructor.name === 'String') {
            return arg.toString();
          }
          return arg;
        });

        // Expand the '~' if appropriate
        var homeDir = getUserHome();
        args = args.map(function (arg) {
          if (typeof arg === 'string' &amp;&amp; arg.slice(0, 2) === '~/' || arg === '~') {
            return arg.replace(/^~/, homeDir);
          }
          return arg;
        });

        // Perform glob-expansion on all arguments after globStart, but preserve
        // the arguments before it (like regexes for sed and grep)
        if (!config.noglob &amp;&amp; options.allowGlobbing === true) {
          args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
        }

        try {
          // parse options if options are provided
          if (isObject(options.cmdOptions)) {
            args[0] = parseOptions(args[0], options.cmdOptions);
          }

          retValue = fn.apply(this, args);
        } catch (e) {
<span class="apidocCodeCommentSpan">          /* istanbul ignore else */
</span>          if (e.msg === 'earlyExit') {
            retValue = e.retValue;
          } else {
            throw e; // this is probably a bug that should be thrown up the call stack
          }
        }
      }
    } catch (e) {
      /* istanbul ignore next */
      if (!state.error) {
        // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
        console.error('ShellJS: internal error');
        console.error(e.stack || e);
        process.exit(1);
      }
      if (config.fatal) throw e;
    }

    if (options.wrapOutput &amp;&amp;
        (typeof retValue === 'string' || Array.isArray(retValue))) {
      retValue = new ShellString(retValue, state.error, state.errorCode);
    }

    state.currentCmd = 'shell.js';
    return retValue;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var shell = require('./shell.js');
var common = require('./src/common');
Object.keys(shell).forEach(function (cmd) {
  global[cmd] = shell[cmd];
});

var _to = require('./src/to');
String.prototype.to = common.<span class="apidocCodeKeywordSpan">wrap</span>('to', _to);

var _toEnd = require('./src/toEnd');
String.prototype.toEnd = common.wrap('toEnd', _toEnd);
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.shelljs.config" id="apidoc.module.shelljs.config">module shelljs.config</a></h1>










    <h2>
        <a href="#apidoc.element.shelljs.config.reset" id="apidoc.element.shelljs.config.reset">
        function <span class="apidocSignatureSpan">shelljs.config.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
  objectAssign(this, DEFAULT_CONFIG);
  if (!isElectron) {
    this.execPath = process.execPath;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
config.globOptions = {nodir: true};
```

Use this value for calls to `glob.sync()` instead of the default options.

### config.<span class="apidocCodeKeywordSpan">reset</span>()

Example:

```javascript
var shell = require('shelljs');
// Make changes to shell.config, and do stuff...
/* ... */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.config.resetForTesting" id="apidoc.element.shelljs.config.resetForTesting">
        function <span class="apidocSignatureSpan">shelljs.config.</span>resetForTesting
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resetForTesting = function () {
  this.reset();
  this.silent = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.shelljs.dirs" id="apidoc.module.shelljs.dirs">module shelljs.dirs</a></h1>


    <h2>
        <a href="#apidoc.element.shelljs.dirs.dirs" id="apidoc.element.shelljs.dirs.dirs">
        function <span class="apidocSignatureSpan">shelljs.</span>dirs
        <span class="apidocSignatureSpan">(options, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _dirs(options, index) {
  if (_isStackIndex(options)) {
    index = options;
    options = '';
  }

  options = common.parseOptions(options, {
    'c': 'clear',
  });

  if (options.clear) {
    _dirStack = [];
    return _dirStack;
  }

  var stack = _actualDirStack();

  if (index) {
    index = _parseStackIndex(index);

    if (index &lt; 0) {
      index = stack.length + index;
    }

    common.log(stack[index]);
    return stack[index];
  }

  common.log(stack.join(' '));

  return stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.dirs.popd" id="apidoc.element.shelljs.dirs.popd">
        function <span class="apidocSignatureSpan">shelljs.dirs.</span>popd
        <span class="apidocSignatureSpan">(options, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _popd(options, index) {
  if (_isStackIndex(options)) {
    index = options;
    options = '';
  }

  options = common.parseOptions(options, {
    'n': 'no-cd',
  });

  if (!_dirStack.length) {
    return common.error('directory stack empty');
  }

  index = _parseStackIndex(index || '+0');

  if (options['no-cd'] || index &gt; 0 || _dirStack.length + index === 0) {
    index = index &gt; 0 ? index - 1 : index;
    _dirStack.splice(index, 1);
  } else {
    var dir = path.resolve(_dirStack.shift());
    _cd('', dir);
  }

  return _dirs('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.dirs.pushd" id="apidoc.element.shelljs.dirs.pushd">
        function <span class="apidocSignatureSpan">shelljs.dirs.</span>pushd
        <span class="apidocSignatureSpan">(options, dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _pushd(options, dir) {
  if (_isStackIndex(options)) {
    dir = options;
    options = '';
  }

  options = common.parseOptions(options, {
    'n': 'no-cd',
  });

  var dirs = _actualDirStack();

  if (dir === '+0') {
    return dirs; // +0 is a noop
  } else if (!dir) {
    if (dirs.length &gt; 1) {
      dirs = dirs.splice(1, 1).concat(dirs);
    } else {
      return common.error('no other directory');
    }
  } else if (_isStackIndex(dir)) {
    var n = _parseStackIndex(dir);
    dirs = dirs.slice(n).concat(dirs.slice(0, n));
  } else {
    if (options['no-cd']) {
      dirs.splice(1, 0, dir);
    } else {
      dirs.unshift(dir);
    }
  }

  if (options['no-cd']) {
    dirs = dirs.slice(1);
  } else {
    dir = path.resolve(dirs.shift());
    _cd('', dir);
  }

  _dirStack = dirs;
  return _dirs('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.shelljs.plugin" id="apidoc.module.shelljs.plugin">module shelljs.plugin</a></h1>


    <h2>
        <a href="#apidoc.element.shelljs.plugin.error" id="apidoc.element.shelljs.plugin.error">
        function <span class="apidocSignatureSpan">shelljs.plugin.</span>error
        <span class="apidocSignatureSpan">(msg, _code, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function error(msg, _code, options) {
  // Validate input
  if (typeof msg !== 'string') throw new Error('msg must be a string');

  var DEFAULT_OPTIONS = {
    continue: false,
    code: 1,
    prefix: state.currentCmd + ': ',
    silent: false,
  };

  if (typeof _code === 'number' &amp;&amp; isObject(options)) {
    options.code = _code;
  } else if (isObject(_code)) { // no 'code'
    options = _code;
  } else if (typeof _code === 'number') { // no 'options'
    options = { code: _code };
  } else if (typeof _code !== 'number') { // only 'msg'
    options = {};
  }
  options = objectAssign({}, DEFAULT_OPTIONS, options);

  if (!state.errorCode) state.errorCode = options.code;

  var logEntry = convertErrorOutput(options.prefix + msg);
  state.error = state.error ? state.error + '\n' : '';
  state.error += logEntry;

  // Throw an error, or log the entry
  if (config.fatal) throw new Error(logEntry);
  if (msg.length &gt; 0 &amp;&amp; !options.silent) log(logEntry);

  if (!options.continue) {
    throw {
      msg: 'earlyExit',
      retValue: (new ShellString('', state.error, state.errorCode)),
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//@
//@ Returns a string containing the given file, or a concatenated string
//@ containing the files if more than one file is given (a new line character is
//@ introduced between each file).
function _cat(options, files) {
var cat = common.readFromPipe();

if (!files &amp;&amp; !cat) common.<span class="apidocCodeKeywordSpan">error</span>('no paths given');

files = [].slice.call(arguments, 1);

files.forEach(function (file) {
  if (!fs.existsSync(file)) {
    common.error('no such file or directory: ' + file);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.plugin.parseOptions" id="apidoc.element.shelljs.plugin.parseOptions">
        function <span class="apidocSignatureSpan">shelljs.plugin.</span>parseOptions
        <span class="apidocSignatureSpan">(opt, map, errorOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseOptions(opt, map, errorOptions) {
  // Validate input
  if (typeof opt !== 'string' &amp;&amp; !isObject(opt)) {
    throw new Error('options must be strings or key-value pairs');
  } else if (!isObject(map)) {
    throw new Error('parseOptions() internal error: map must be an object');
  } else if (errorOptions &amp;&amp; !isObject(errorOptions)) {
    throw new Error('parseOptions() internal error: errorOptions must be object');
  }

  // All options are false by default
  var options = {};
  Object.keys(map).forEach(function (letter) {
    var optName = map[letter];
    if (optName[0] !== '!') {
      options[optName] = false;
    }
  });

  if (opt === '') return options; // defaults

  if (typeof opt === 'string') {
    if (opt[0] !== '-') {
      error("Options string must start with a '-'", errorOptions || {});
    }

    // e.g. chars = ['R', 'f']
    var chars = opt.slice(1).split('');

    chars.forEach(function (c) {
      if (c in map) {
        var optionName = map[c];
        if (optionName[0] === '!') {
          options[optionName.slice(1)] = false;
        } else {
          options[optionName] = true;
        }
      } else {
        error('option not recognized: ' + c, errorOptions || {});
      }
    });
  } else { // opt is an Object
    Object.keys(opt).forEach(function (key) {
      // key is a string of the form '-r', '-d', etc.
      var c = key[1];
      if (c in map) {
        var optionName = map[c];
        options[optionName] = opt[key]; // assign the given value
      } else {
        error('option not recognized: ' + c, errorOptions || {});
      }
    });
  }
  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // If we are down by one argument and options starts with -, shift everything over.
    [].unshift.call(arguments, '');
  } else {
    common.error('You must specify a file.');
  }
}

options = common.<span class="apidocCodeKeywordSpan">parseOptions</span>(options, {
  'R': 'recursive',
  'c': 'changes',
  'v': 'verbose',
});

filePattern = [].slice.call(arguments, 2);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.plugin.readFromPipe" id="apidoc.element.shelljs.plugin.readFromPipe">
        function <span class="apidocSignatureSpan">shelljs.plugin.</span>readFromPipe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _readFromPipe() {
  return state.pipedValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//@ var str = cat(['file1', 'file2']); // same as above
//@ ```
//@
//@ Returns a string containing the given file, or a concatenated string
//@ containing the files if more than one file is given (a new line character is
//@ introduced between each file).
function _cat(options, files) {
var cat = common.<span class="apidocCodeKeywordSpan">readFromPipe</span>();

if (!files &amp;&amp; !cat) common.error('no paths given');

files = [].slice.call(arguments, 1);

files.forEach(function (file) {
  if (!fs.existsSync(file)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.plugin.register" id="apidoc.element.shelljs.plugin.register">
        function <span class="apidocSignatureSpan">shelljs.plugin.</span>register
        <span class="apidocSignatureSpan">(name, implementation, wrapOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _register(name, implementation, wrapOptions) {
  wrapOptions = wrapOptions || {};
  // If an option isn't specified, use the default
  wrapOptions = objectAssign({}, DEFAULT_WRAP_OPTIONS, wrapOptions);

  if (shell[name] &amp;&amp; !wrapOptions.overWrite) {
    throw new Error('unable to overwrite `' + name + '` command');
  }

  if (wrapOptions.pipeOnly) {
    wrapOptions.canReceivePipe = true;
    shellMethods[name] = wrap(name, implementation, wrapOptions);
  } else {
    shell[name] = wrap(name, implementation, wrapOptions);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...




var common = require('./common');
var fs = require('fs');

common.<span class="apidocCodeKeywordSpan">register</span>('cat', _cat, {
  canReceivePipe: true,
});

//@
//@ ### cat(file [, file ...])
//@ ### cat(file_array)
//@
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>