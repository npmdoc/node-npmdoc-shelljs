<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://github.com/shelljs/shelljs"

    >shelljs (v0.7.7)</a>
</h1>
<h4>Portable Unix shell commands for Node.js</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.shelljs">module shelljs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.ShellString">
            function <span class="apidocSignatureSpan">shelljs.</span>ShellString
            <span class="apidocSignatureSpan">(stdout, stderr, code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.cat">
            function <span class="apidocSignatureSpan">shelljs.</span>cat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.cd">
            function <span class="apidocSignatureSpan">shelljs.</span>cd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.chmod">
            function <span class="apidocSignatureSpan">shelljs.</span>chmod
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.cp">
            function <span class="apidocSignatureSpan">shelljs.</span>cp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.dirs">
            function <span class="apidocSignatureSpan">shelljs.</span>dirs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.echo">
            function <span class="apidocSignatureSpan">shelljs.</span>echo
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.error">
            function <span class="apidocSignatureSpan">shelljs.</span>error
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.exec">
            function <span class="apidocSignatureSpan">shelljs.</span>exec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.exit">
            function <span class="apidocSignatureSpan">shelljs.</span>exit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.find">
            function <span class="apidocSignatureSpan">shelljs.</span>find
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.grep">
            function <span class="apidocSignatureSpan">shelljs.</span>grep
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.head">
            function <span class="apidocSignatureSpan">shelljs.</span>head
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.ln">
            function <span class="apidocSignatureSpan">shelljs.</span>ln
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.ls">
            function <span class="apidocSignatureSpan">shelljs.</span>ls
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.mkdir">
            function <span class="apidocSignatureSpan">shelljs.</span>mkdir
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.mv">
            function <span class="apidocSignatureSpan">shelljs.</span>mv
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.popd">
            function <span class="apidocSignatureSpan">shelljs.</span>popd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.pushd">
            function <span class="apidocSignatureSpan">shelljs.</span>pushd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.pwd">
            function <span class="apidocSignatureSpan">shelljs.</span>pwd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.rm">
            function <span class="apidocSignatureSpan">shelljs.</span>rm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.sed">
            function <span class="apidocSignatureSpan">shelljs.</span>sed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.set">
            function <span class="apidocSignatureSpan">shelljs.</span>set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.sort">
            function <span class="apidocSignatureSpan">shelljs.</span>sort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.tail">
            function <span class="apidocSignatureSpan">shelljs.</span>tail
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.tempdir">
            function <span class="apidocSignatureSpan">shelljs.</span>tempdir
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.test">
            function <span class="apidocSignatureSpan">shelljs.</span>test
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.touch">
            function <span class="apidocSignatureSpan">shelljs.</span>touch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.uniq">
            function <span class="apidocSignatureSpan">shelljs.</span>uniq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.which">
            function <span class="apidocSignatureSpan">shelljs.</span>which
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">shelljs.</span>common</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">shelljs.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">shelljs.</span>plugin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">shelljs.</span>shell</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.shelljs.common">module shelljs.common</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.ShellString">
            function <span class="apidocSignatureSpan">shelljs.common.</span>ShellString
            <span class="apidocSignatureSpan">(stdout, stderr, code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.convertErrorOutput">
            function <span class="apidocSignatureSpan">shelljs.common.</span>convertErrorOutput
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.error">
            function <span class="apidocSignatureSpan">shelljs.common.</span>error
            <span class="apidocSignatureSpan">(msg, _code, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.expand">
            function <span class="apidocSignatureSpan">shelljs.common.</span>expand
            <span class="apidocSignatureSpan">(list)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.extend">
            function <span class="apidocSignatureSpan">shelljs.common.</span>extend
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.getUserHome">
            function <span class="apidocSignatureSpan">shelljs.common.</span>getUserHome
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.isObject">
            function <span class="apidocSignatureSpan">shelljs.common.</span>isObject
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.log">
            function <span class="apidocSignatureSpan">shelljs.common.</span>log
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.parseOptions">
            function <span class="apidocSignatureSpan">shelljs.common.</span>parseOptions
            <span class="apidocSignatureSpan">(opt, map, errorOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.randomFileName">
            function <span class="apidocSignatureSpan">shelljs.common.</span>randomFileName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.readFromPipe">
            function <span class="apidocSignatureSpan">shelljs.common.</span>readFromPipe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.register">
            function <span class="apidocSignatureSpan">shelljs.common.</span>register
            <span class="apidocSignatureSpan">(name, implementation, wrapOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.unlinkSync">
            function <span class="apidocSignatureSpan">shelljs.common.</span>unlinkSync
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.common.wrap">
            function <span class="apidocSignatureSpan">shelljs.common.</span>wrap
            <span class="apidocSignatureSpan">(cmd, fn, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">shelljs.common.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">shelljs.common.</span>state</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">shelljs.common.</span>platform</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.shelljs.config">module shelljs.config</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">shelljs.config.</span>fatal</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">shelljs.config.</span>noglob</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">shelljs.config.</span>silent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">shelljs.config.</span>verbose</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.config.reset">
            function <span class="apidocSignatureSpan">shelljs.config.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.config.resetForTesting">
            function <span class="apidocSignatureSpan">shelljs.config.</span>resetForTesting
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">shelljs.config.</span>maxdepth</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">shelljs.config.</span>globOptions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">shelljs.config.</span>execPath</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.shelljs.dirs">module shelljs.dirs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.dirs.dirs">
            function <span class="apidocSignatureSpan">shelljs.</span>dirs
            <span class="apidocSignatureSpan">(options, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.dirs.popd">
            function <span class="apidocSignatureSpan">shelljs.dirs.</span>popd
            <span class="apidocSignatureSpan">(options, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.dirs.pushd">
            function <span class="apidocSignatureSpan">shelljs.dirs.</span>pushd
            <span class="apidocSignatureSpan">(options, dir)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.shelljs.plugin">module shelljs.plugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.plugin.error">
            function <span class="apidocSignatureSpan">shelljs.plugin.</span>error
            <span class="apidocSignatureSpan">(msg, _code, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.plugin.parseOptions">
            function <span class="apidocSignatureSpan">shelljs.plugin.</span>parseOptions
            <span class="apidocSignatureSpan">(opt, map, errorOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.plugin.readFromPipe">
            function <span class="apidocSignatureSpan">shelljs.plugin.</span>readFromPipe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.plugin.register">
            function <span class="apidocSignatureSpan">shelljs.plugin.</span>register
            <span class="apidocSignatureSpan">(name, implementation, wrapOptions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.shelljs.shell">module shelljs.shell</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.ShellString">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>ShellString
            <span class="apidocSignatureSpan">(stdout, stderr, code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.cat">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>cat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.cd">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>cd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.chmod">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>chmod
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.cp">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>cp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.dirs">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>dirs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.echo">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>echo
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.error">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>error
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.exec">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>exec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.exit">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>exit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.find">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>find
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.grep">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>grep
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.head">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>head
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.ln">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>ln
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.ls">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>ls
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.mkdir">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>mkdir
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.mv">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>mv
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.popd">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>popd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.pushd">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>pushd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.pwd">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>pwd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.rm">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>rm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.sed">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>sed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.set">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.sort">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>sort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.tail">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>tail
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.tempdir">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>tempdir
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.test">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>test
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.touch">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>touch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.uniq">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>uniq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.shelljs.shell.which">
            function <span class="apidocSignatureSpan">shelljs.shell.</span>which
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">shelljs.shell.</span>config</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.shelljs" id="apidoc.module.shelljs">module shelljs</a></h1>


    <h2>
        <a href="#apidoc.element.shelljs.ShellString" id="apidoc.element.shelljs.ShellString">
        function <span class="apidocSignatureSpan">shelljs.</span>ShellString
        <span class="apidocSignatureSpan">(stdout, stderr, code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ShellString(stdout, stderr, code) {
  var that;
  if (stdout instanceof Array) {
    that = stdout;
    that.stdout = stdout.join(&#x27;\n&#x27;);
    if (stdout.length &#x3e; 0) that.stdout += &#x27;\n&#x27;;
  } else {
    that = new String(stdout);
    that.stdout = stdout;
  }
  that.stderr = stderr;
  that.code = code;
  // A list of all commands that can appear on the right-hand side of a pipe
  // (populated by calls to common.wrap())
  pipeMethods.forEach(function (cmd) {
    that[cmd] = shellMethods[cmd].bind(that);
  });
  return that;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Dest is not existing dir, but multiple sources given
if ((!destExists || !destStat.isDirectory()) &#x26;&#x26; sources.length &#x3e; 1) {
  common.error(&#x27;dest is not a directory (too many sources)&#x27;);
}

// Dest is an existing file, but -n is given
if (destExists &#x26;&#x26; destStat.isFile() &#x26;&#x26; options.no_force) {
  return new common.<span class="apidocCodeKeywordSpan">ShellString</span>(&#x27;&#x27;, &#x27;&#x27;, 0);
}

sources.forEach(function (src) {
  if (!fs.existsSync(src)) {
    common.error(&#x27;no such file or directory: &#x27; + src, { continue: true });
    return; // skip file
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.cat" id="apidoc.element.shelljs.cat">
        function <span class="apidocSignatureSpan">shelljs.</span>cat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cat = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
shell.cd(&#x27;lib&#x27;);
shell.ls(&#x27;*.js&#x27;).forEach(function (file) {
shell.sed(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
shell.sed(&#x27;-i&#x27;, /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.<span class="apidocCodeKeywordSpan">cat</span>(&#x27;macro.js&#
x27;), file);
});
shell.cd(&#x27;..&#x27;);

// Run external tool synchronously
if (shell.exec(&#x27;git commit -am &#x22;Auto-commit&#x22;&#x27;).code !== 0) {
shell.echo(&#x27;Error: Git commit failed&#x27;);
shell.exit(1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.cd" id="apidoc.element.shelljs.cd">
        function <span class="apidocSignatureSpan">shelljs.</span>cd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cd = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
shell.<span class="apidocCodeKeywordSpan">cd</span>(&#x27;lib&#x27;);
shell.ls(&#x27;*.js&#x27;).forEach(function (file) {
  shell.sed(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat(&#x27;macro.js&#x27;), file);
});
shell.cd(&#x27;..&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.chmod" id="apidoc.element.shelljs.chmod">
        function <span class="apidocSignatureSpan">shelljs.</span>chmod
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chmod = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.cp" id="apidoc.element.shelljs.cp">
        function <span class="apidocSignatureSpan">shelljs.</span>cp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cp = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!shell.which(&#x27;git&#x27;)) {
shell.echo(&#x27;Sorry, this script requires git&#x27;);
shell.exit(1);
}

// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.<span class="apidocCodeKeywordSpan">cp</span>(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
shell.cd(&#x27;lib&#x27;);
shell.ls(&#x27;*.js&#x27;).forEach(function (file) {
shell.sed(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
shell.sed(&#x27;-i&#x27;, /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat(&#x27;macro.js&#x27;), file);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.dirs" id="apidoc.element.shelljs.dirs">
        function <span class="apidocSignatureSpan">shelljs.</span>dirs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dirs = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.echo" id="apidoc.element.shelljs.echo">
        function <span class="apidocSignatureSpan">shelljs.</span>echo
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">echo = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Examples

```javascript
var shell = require(&#x27;shelljs&#x27;);

if (!shell.which(&#x27;git&#x27;)) {
  shell.<span class="apidocCodeKeywordSpan">echo</span>(&#x27;Sorry, this script requires git&#x27;);
  shell.exit(1);
}

// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.error" id="apidoc.element.shelljs.error">
        function <span class="apidocSignatureSpan">shelljs.</span>error
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function error() {
  return common.state.error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//@
//@ Returns a string containing the given file, or a concatenated string
//@ containing the files if more than one file is given (a new line character is
//@ introduced between each file).
function _cat(options, files) {
var cat = common.readFromPipe();

if (!files &#x26;&#x26; !cat) common.<span class="apidocCodeKeywordSpan">error</span>(&#x27;no paths given&#x27;);

files = [].slice.call(arguments, 1);

files.forEach(function (file) {
  if (!fs.existsSync(file)) {
    common.error(&#x27;no such file or directory: &#x27; + file);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.exec" id="apidoc.element.shelljs.exec">
        function <span class="apidocSignatureSpan">shelljs.</span>exec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  shell.sed(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat(&#x27;macro.js&#x27;), file);
});
shell.cd(&#x27;..&#x27;);

// Run external tool synchronously
if (shell.<span class="apidocCodeKeywordSpan">exec</span>(&#x27;git commit -am &#x22;Auto-commit&#x22;&#x27;).code !== 0) {
  shell.echo(&#x27;Error: Git commit failed&#x27;);
  shell.exit(1);
}
```

## Global vs. Local
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.exit" id="apidoc.element.shelljs.exit">
        function <span class="apidocSignatureSpan">shelljs.</span>exit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exit = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Examples

```javascript
var shell = require(&#x27;shelljs&#x27;);

if (!shell.which(&#x27;git&#x27;)) {
  shell.echo(&#x27;Sorry, this script requires git&#x27;);
  shell.<span class="apidocCodeKeywordSpan">exit</span>(1);
}

// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.find" id="apidoc.element.shelljs.find">
        function <span class="apidocSignatureSpan">shelljs.</span>find
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.grep" id="apidoc.element.shelljs.grep">
        function <span class="apidocSignatureSpan">shelljs.</span>grep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">grep = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### Pipes

Examples:

```javascript
grep(&#x27;foo&#x27;, &#x27;file1.txt&#x27;, &#x27;file2.txt&#x27;).sed(/o/g, &#x27;a&#x27;).to(&#x27;output.txt&#x27;);
echo(&#x27;files with o\&#x27;s in the name:\n&#x27; + ls().<span class="apidocCodeKeywordSpan">grep</span>(&#x27;o&#x27;));
cat(&#x27;test.js&#x27;).exec(&#x27;node&#x27;); // pipe to exec() call
```

Commands can send their output to another command in a pipe-like fashion.
`sed`, `grep`, `cat`, `exec`, `to`, and `toEnd` can appear on the right-hand
side of a pipe. Pipes can be chained.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.head" id="apidoc.element.shelljs.head">
        function <span class="apidocSignatureSpan">shelljs.</span>head
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">head = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.ln" id="apidoc.element.shelljs.ln">
        function <span class="apidocSignatureSpan">shelljs.</span>ln
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ln = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.ls" id="apidoc.element.shelljs.ls">
        function <span class="apidocSignatureSpan">shelljs.</span>ls
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ls = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
shell.cd(&#x27;lib&#x27;);
shell.<span class="apidocCodeKeywordSpan">ls</span>(&#x27;*.js&#x27;).forEach(function (file) {
  shell.sed(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat(&#x27;macro.js&#x27;), file);
});
shell.cd(&#x27;..&#x27;);

// Run external tool synchronously
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.mkdir" id="apidoc.element.shelljs.mkdir">
        function <span class="apidocSignatureSpan">shelljs.</span>mkdir
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdir = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.mv" id="apidoc.element.shelljs.mv">
        function <span class="apidocSignatureSpan">shelljs.</span>mv
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mv = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.popd" id="apidoc.element.shelljs.popd">
        function <span class="apidocSignatureSpan">shelljs.</span>popd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">popd = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.pushd" id="apidoc.element.shelljs.pushd">
        function <span class="apidocSignatureSpan">shelljs.</span>pushd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pushd = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.pwd" id="apidoc.element.shelljs.pwd">
        function <span class="apidocSignatureSpan">shelljs.</span>pwd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pwd = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.rm" id="apidoc.element.shelljs.rm">
        function <span class="apidocSignatureSpan">shelljs.</span>rm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rm = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (!shell.which(&#x27;git&#x27;)) {
shell.echo(&#x27;Sorry, this script requires git&#x27;);
shell.exit(1);
}

// Copy files to release dir
shell.<span class="apidocCodeKeywordSpan">rm</span>(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
shell.cd(&#x27;lib&#x27;);
shell.ls(&#x27;*.js&#x27;).forEach(function (file) {
shell.sed(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.sed" id="apidoc.element.shelljs.sed">
        function <span class="apidocSignatureSpan">shelljs.</span>sed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sed = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
shell.cd(&#x27;lib&#x27;);
shell.ls(&#x27;*.js&#x27;).forEach(function (file) {
  shell.<span class="apidocCodeKeywordSpan">sed</span>(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat(&#x27;macro.js&#x27;), file);
});
shell.cd(&#x27;..&#x27;);

// Run external tool synchronously
if (shell.exec(&#x27;git commit -am &#x22;Auto-commit&#x22;&#x27;).code !== 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.set" id="apidoc.element.shelljs.set">
        function <span class="apidocSignatureSpan">shelljs.</span>set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.sort" id="apidoc.element.shelljs.sort">
        function <span class="apidocSignatureSpan">shelljs.</span>sort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sort = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    var contents = file === &#x27;-&#x27; ? pipe : fs.readFileSync(file, &#x27;utf8&#x27;);
    lines = lines.concat(contents.trimRight().split(/\r*\n/));
  });

  var sorted;
  sorted = lines.<span class="apidocCodeKeywordSpan">sort</span>(options.numerical ? numericalCmp : unixCmp);

  if (options.reverse) {
    sorted = sorted.reverse();
  }

  return sorted.join(&#x27;\n&#x27;) + &#x27;\n&#x27;;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.tail" id="apidoc.element.shelljs.tail">
        function <span class="apidocSignatureSpan">shelljs.</span>tail
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tail = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.tempdir" id="apidoc.element.shelljs.tempdir">
        function <span class="apidocSignatureSpan">shelljs.</span>tempdir
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tempdir = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.test" id="apidoc.element.shelljs.test">
        function <span class="apidocSignatureSpan">shelljs.</span>test
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">test = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    //   $ cd ../../../..
    //   $ cp -RL 1 copy
    var cyclecheck = fs.statSync(srcFile);
    if (cyclecheck.isDirectory()) {
      var sourcerealpath = fs.realpathSync(sourceDir);
      var symlinkrealpath = fs.realpathSync(srcFile);
      var re = new RegExp(symlinkrealpath);
      if (re.<span class="apidocCodeKeywordSpan">test</span>(sourcerealpath)) {
        return true;
      }
    }
  }
  return false;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.touch" id="apidoc.element.shelljs.touch">
        function <span class="apidocSignatureSpan">shelljs.</span>touch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">touch = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.uniq" id="apidoc.element.shelljs.uniq">
        function <span class="apidocSignatureSpan">shelljs.</span>uniq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uniq = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.which" id="apidoc.element.shelljs.which">
        function <span class="apidocSignatureSpan">shelljs.</span>which
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">which = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

## Examples

```javascript
var shell = require(&#x27;shelljs&#x27;);

if (!shell.<span class="apidocCodeKeywordSpan">which</span>(&#x27;git&#x27;)) {
  shell.echo(&#x27;Sorry, this script requires git&#x27;);
  shell.exit(1);
}

// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.shelljs.common" id="apidoc.module.shelljs.common">module shelljs.common</a></h1>


    <h2>
        <a href="#apidoc.element.shelljs.common.ShellString" id="apidoc.element.shelljs.common.ShellString">
        function <span class="apidocSignatureSpan">shelljs.common.</span>ShellString
        <span class="apidocSignatureSpan">(stdout, stderr, code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ShellString(stdout, stderr, code) {
  var that;
  if (stdout instanceof Array) {
    that = stdout;
    that.stdout = stdout.join(&#x27;\n&#x27;);
    if (stdout.length &#x3e; 0) that.stdout += &#x27;\n&#x27;;
  } else {
    that = new String(stdout);
    that.stdout = stdout;
  }
  that.stderr = stderr;
  that.code = code;
  // A list of all commands that can appear on the right-hand side of a pipe
  // (populated by calls to common.wrap())
  pipeMethods.forEach(function (cmd) {
    that[cmd] = shellMethods[cmd].bind(that);
  });
  return that;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Dest is not existing dir, but multiple sources given
if ((!destExists || !destStat.isDirectory()) &#x26;&#x26; sources.length &#x3e; 1) {
  common.error(&#x27;dest is not a directory (too many sources)&#x27;);
}

// Dest is an existing file, but -n is given
if (destExists &#x26;&#x26; destStat.isFile() &#x26;&#x26; options.no_force) {
  return new common.<span class="apidocCodeKeywordSpan">ShellString</span>(&#x27;&#x27;, &#x27;&#x27;, 0);
}

sources.forEach(function (src) {
  if (!fs.existsSync(src)) {
    common.error(&#x27;no such file or directory: &#x27; + src, { continue: true });
    return; // skip file
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.convertErrorOutput" id="apidoc.element.shelljs.common.convertErrorOutput">
        function <span class="apidocSignatureSpan">shelljs.common.</span>convertErrorOutput
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convertErrorOutput(msg) {
  if (typeof msg !== &#x27;string&#x27;) {
    throw new TypeError(&#x27;input must be a string&#x27;);
  }
  return msg.replace(/\\/g, &#x27;/&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.error" id="apidoc.element.shelljs.common.error">
        function <span class="apidocSignatureSpan">shelljs.common.</span>error
        <span class="apidocSignatureSpan">(msg, _code, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function error(msg, _code, options) {
  // Validate input
  if (typeof msg !== &#x27;string&#x27;) throw new Error(&#x27;msg must be a string&#x27;);

  var DEFAULT_OPTIONS = {
    continue: false,
    code: 1,
    prefix: state.currentCmd + &#x27;: &#x27;,
    silent: false,
  };

  if (typeof _code === &#x27;number&#x27; &#x26;&#x26; isObject(options)) {
    options.code = _code;
  } else if (isObject(_code)) { // no &#x27;code&#x27;
    options = _code;
  } else if (typeof _code === &#x27;number&#x27;) { // no &#x27;options&#x27;
    options = { code: _code };
  } else if (typeof _code !== &#x27;number&#x27;) { // only &#x27;msg&#x27;
    options = {};
  }
  options = objectAssign({}, DEFAULT_OPTIONS, options);

  if (!state.errorCode) state.errorCode = options.code;

  var logEntry = convertErrorOutput(options.prefix + msg);
  state.error = state.error ? state.error + &#x27;\n&#x27; : &#x27;&#x27;;
  state.error += logEntry;

  // Throw an error, or log the entry
  if (config.fatal) throw new Error(logEntry);
  if (msg.length &#x3e; 0 &#x26;&#x26; !options.silent) log(logEntry);

  if (!options.continue) {
    throw {
      msg: &#x27;earlyExit&#x27;,
      retValue: (new ShellString(&#x27;&#x27;, state.error, state.errorCode)),
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//@
//@ Returns a string containing the given file, or a concatenated string
//@ containing the files if more than one file is given (a new line character is
//@ introduced between each file).
function _cat(options, files) {
var cat = common.readFromPipe();

if (!files &#x26;&#x26; !cat) common.<span class="apidocCodeKeywordSpan">error</span>(&#x27;no paths given&#x27;);

files = [].slice.call(arguments, 1);

files.forEach(function (file) {
  if (!fs.existsSync(file)) {
    common.error(&#x27;no such file or directory: &#x27; + file);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.expand" id="apidoc.element.shelljs.common.expand">
        function <span class="apidocSignatureSpan">shelljs.common.</span>expand
        <span class="apidocSignatureSpan">(list)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function expand(list) {
  if (!Array.isArray(list)) {
    throw new TypeError(&#x27;must be an array&#x27;);
  }
  var expanded = [];
  list.forEach(function (listEl) {
    // Don&#x27;t expand non-strings
    if (typeof listEl !== &#x27;string&#x27;) {
      expanded.push(listEl);
    } else {
      var ret = glob.sync(listEl, config.globOptions);
      // if glob fails, interpret the string literally
      expanded = expanded.concat(ret.length &#x3e; 0 ? ret : [listEl]);
    }
  });
  return expanded;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x27;v&#x27;: &#x27;verbose&#x27;,
  });

  filePattern = [].slice.call(arguments, 2);

  var files;

  // TODO: replace this with a call to common.<span class="apidocCodeKeywordSpan">expand</span>()
  if (options.recursive) {
    files = [];
    filePattern.forEach(function addFile(expandedFile) {
var stat = fs.lstatSync(expandedFile);

if (!stat.isSymbolicLink()) {
  files.push(expandedFile);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.extend" id="apidoc.element.shelljs.common.extend">
        function <span class="apidocSignatureSpan">shelljs.common.</span>extend
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function assign() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var tempDir = _tempDir();
var stdoutFile = path.resolve(tempDir + &#x27;/&#x27; + common.randomFileName());
var stderrFile = path.resolve(tempDir + &#x27;/&#x27; + common.randomFileName());
var codeFile = path.resolve(tempDir + &#x27;/&#x27; + common.randomFileName());
var scriptFile = path.resolve(tempDir + &#x27;/&#x27; + common.randomFileName());
var sleepFile = path.resolve(tempDir + &#x27;/&#x27; + common.randomFileName());

opts = common.<span class="apidocCodeKeywordSpan">extend</span>({
  silent: common.config.silent,
  cwd: _pwd().toString(),
  env: process.env,
  maxBuffer: DEFAULT_MAXBUFFER_SIZE,
}, opts);

var previousStdoutContent = &#x27;&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.getUserHome" id="apidoc.element.shelljs.common.getUserHome">
        function <span class="apidocSignatureSpan">shelljs.common.</span>getUserHome
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getUserHome() {
  var result;
  if (os.homedir) {
    result = os.homedir(); // node 3+
  } else {
    result = process.env[(process.platform === &#x27;win32&#x27;) ? &#x27;USERPROFILE&#x27; : &#x27;HOME&#x27;];
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
common.register(&#x27;cd&#x27;, _cd, {});

//@
//@ ### cd([dir])
//@ Changes to directory `dir` for the duration of the script. Changes to home
//@ directory if no argument is supplied.
function _cd(options, dir) {
if (!dir) dir = common.<span class="apidocCodeKeywordSpan">getUserHome</span>();

if (dir === &#x27;-&#x27;) {
  if (!process.env.OLDPWD) {
    common.error(&#x27;could not find previous directory&#x27;);
  } else {
    dir = process.env.OLDPWD;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.isObject" id="apidoc.element.shelljs.common.isObject">
        function <span class="apidocSignatureSpan">shelljs.common.</span>isObject
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObject(a) {
  return typeof a === &#x27;object&#x27; &#x26;&#x26; a !== null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.log" id="apidoc.element.shelljs.common.log">
        function <span class="apidocSignatureSpan">shelljs.common.</span>log
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log() {
<span class="apidocCodeCommentSpan">  /* istanbul ignore next */
</span>  if (!config.silent) {
    console.error.apply(console, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var child = exec(&#x27;some_long_running_process&#x27;, {async:true});
child.stdout.on(&#x27;data&#x27;, function(data) {
  /* ... do something with data ... */
});

exec(&#x27;some_long_running_process&#x27;, function(code, stdout, stderr) {
  console.<span class="apidocCodeKeywordSpan">log</span>(&#x27;Exit code:&#x27;, code);
  console.log(&#x27;Program output:&#x27;, stdout);
  console.log(&#x27;Program stderr:&#x27;, stderr);
});
```

Executes the given `command` _synchronously_, unless otherwise specified.  When in synchronous
mode, this returns a ShellString (compatible with ShellJS v0.6.x, which returns an object
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.parseOptions" id="apidoc.element.shelljs.common.parseOptions">
        function <span class="apidocSignatureSpan">shelljs.common.</span>parseOptions
        <span class="apidocSignatureSpan">(opt, map, errorOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseOptions(opt, map, errorOptions) {
  // Validate input
  if (typeof opt !== &#x27;string&#x27; &#x26;&#x26; !isObject(opt)) {
    throw new Error(&#x27;options must be strings or key-value pairs&#x27;);
  } else if (!isObject(map)) {
    throw new Error(&#x27;parseOptions() internal error: map must be an object&#x27;);
  } else if (errorOptions &#x26;&#x26; !isObject(errorOptions)) {
    throw new Error(&#x27;parseOptions() internal error: errorOptions must be object&#x27;);
  }

  // All options are false by default
  var options = {};
  Object.keys(map).forEach(function (letter) {
    var optName = map[letter];
    if (optName[0] !== &#x27;!&#x27;) {
      options[optName] = false;
    }
  });

  if (opt === &#x27;&#x27;) return options; // defaults

  if (typeof opt === &#x27;string&#x27;) {
    if (opt[0] !== &#x27;-&#x27;) {
      error(&#x22;Options string must start with a &#x27;-&#x27;&#x22;, errorOptions || {});
    }

    // e.g. chars = [&#x27;R&#x27;, &#x27;f&#x27;]
    var chars = opt.slice(1).split(&#x27;&#x27;);

    chars.forEach(function (c) {
      if (c in map) {
        var optionName = map[c];
        if (optionName[0] === &#x27;!&#x27;) {
          options[optionName.slice(1)] = false;
        } else {
          options[optionName] = true;
        }
      } else {
        error(&#x27;option not recognized: &#x27; + c, errorOptions || {});
      }
    });
  } else { // opt is an Object
    Object.keys(opt).forEach(function (key) {
      // key is a string of the form &#x27;-r&#x27;, &#x27;-d&#x27;, etc.
      var c = key[1];
      if (c in map) {
        var optionName = map[c];
        options[optionName] = opt[key]; // assign the given value
      } else {
        error(&#x27;option not recognized: &#x27; + c, errorOptions || {});
      }
    });
  }
  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // If we are down by one argument and options starts with -, shift everything over.
    [].unshift.call(arguments, &#x27;&#x27;);
  } else {
    common.error(&#x27;You must specify a file.&#x27;);
  }
}

options = common.<span class="apidocCodeKeywordSpan">parseOptions</span>(options, {
  &#x27;R&#x27;: &#x27;recursive&#x27;,
  &#x27;c&#x27;: &#x27;changes&#x27;,
  &#x27;v&#x27;: &#x27;verbose&#x27;,
});

filePattern = [].slice.call(arguments, 2);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.randomFileName" id="apidoc.element.shelljs.common.randomFileName">
        function <span class="apidocSignatureSpan">shelljs.common.</span>randomFileName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function randomFileName() {
  function randomHash(count) {
    if (count === 1) {
      return parseInt(16 * Math.random(), 10).toString(16);
    }
    var hash = &#x27;&#x27;;
    for (var i = 0; i &#x3c; count; i++) {
      hash += randomHash(1);
    }
    return hash;
  }

  return &#x27;shelljs_&#x27; + randomHash(20);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// event loop).
function execSync(cmd, opts, pipe) {
if (!common.config.execPath) {
  common.error(&#x27;Unable to find a path to the node binary. Please manually set config.execPath&#x27;);
}

var tempDir = _tempDir();
var stdoutFile = path.resolve(tempDir + &#x27;/&#x27; + common.<span class="apidocCodeKeywordSpan">randomFileName</span>());
var stderrFile = path.resolve(tempDir + &#x27;/&#x27; + common.randomFileName());
var codeFile = path.resolve(tempDir + &#x27;/&#x27; + common.randomFileName());
var scriptFile = path.resolve(tempDir + &#x27;/&#x27; + common.randomFileName());
var sleepFile = path.resolve(tempDir + &#x27;/&#x27; + common.randomFileName());

opts = common.extend({
  silent: common.config.silent,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.readFromPipe" id="apidoc.element.shelljs.common.readFromPipe">
        function <span class="apidocSignatureSpan">shelljs.common.</span>readFromPipe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _readFromPipe() {
  return state.pipedValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//@ var str = cat([&#x27;file1&#x27;, &#x27;file2&#x27;]); // same as above
//@ ```
//@
//@ Returns a string containing the given file, or a concatenated string
//@ containing the files if more than one file is given (a new line character is
//@ introduced between each file).
function _cat(options, files) {
var cat = common.<span class="apidocCodeKeywordSpan">readFromPipe</span>();

if (!files &#x26;&#x26; !cat) common.error(&#x27;no paths given&#x27;);

files = [].slice.call(arguments, 1);

files.forEach(function (file) {
  if (!fs.existsSync(file)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.register" id="apidoc.element.shelljs.common.register">
        function <span class="apidocSignatureSpan">shelljs.common.</span>register
        <span class="apidocSignatureSpan">(name, implementation, wrapOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _register(name, implementation, wrapOptions) {
  wrapOptions = wrapOptions || {};
  // If an option isn&#x27;t specified, use the default
  wrapOptions = objectAssign({}, DEFAULT_WRAP_OPTIONS, wrapOptions);

  if (shell[name] &#x26;&#x26; !wrapOptions.overWrite) {
    throw new Error(&#x27;unable to overwrite `&#x27; + name + &#x27;` command&#x27;);
  }

  if (wrapOptions.pipeOnly) {
    wrapOptions.canReceivePipe = true;
    shellMethods[name] = wrap(name, implementation, wrapOptions);
  } else {
    shell[name] = wrap(name, implementation, wrapOptions);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...




var common = require(&#x27;./common&#x27;);
var fs = require(&#x27;fs&#x27;);

common.<span class="apidocCodeKeywordSpan">register</span>(&#x27;cat&#x27;, _cat, {
  canReceivePipe: true,
});

//@
//@ ### cat(file [, file ...])
//@ ### cat(file_array)
//@
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.unlinkSync" id="apidoc.element.shelljs.common.unlinkSync">
        function <span class="apidocSignatureSpan">shelljs.common.</span>unlinkSync
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unlinkSync(file) {
  try {
    fs.unlinkSync(file);
  } catch (e) {
    // Try to override file permission
<span class="apidocCodeCommentSpan">    /* istanbul ignore next */
</span>    if (e.code === &#x27;EPERM&#x27;) {
      fs.chmodSync(file, &#x27;0666&#x27;);
      fs.unlinkSync(file);
    } else {
      throw e;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
exports.expand = expand;

// Normalizes _unlinkSync() across platforms to match Unix behavior, i.e.
// file can be unlinked even if it&#x27;s read-only, see https://github.com/joyent/node/issues/3006
function unlinkSync(file) {
try {
  fs.<span class="apidocCodeKeywordSpan">unlinkSync</span>(file);
} catch (e) {
  // Try to override file permission
  /* istanbul ignore next */
  if (e.code === &#x27;EPERM&#x27;) {
    fs.chmodSync(file, &#x27;0666&#x27;);
    fs.unlinkSync(file);
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.common.wrap" id="apidoc.element.shelljs.common.wrap">
        function <span class="apidocSignatureSpan">shelljs.common.</span>wrap
        <span class="apidocSignatureSpan">(cmd, fn, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrap(cmd, fn, options) {
  options = options || {};
  if (options.canReceivePipe) {
    pipeMethods.push(cmd);
  }
  return function () {
    var retValue = null;

    state.currentCmd = cmd;
    state.error = null;
    state.errorCode = 0;

    try {
      var args = [].slice.call(arguments, 0);

      // Log the command to stderr, if appropriate
      if (config.verbose) {
        console.error.apply(console, [cmd].concat(args));
      }

      // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
      // it to the empty string)
      state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

      if (options.unix === false) { // this branch is for exec()
        retValue = fn.apply(this, args);
      } else { // and this branch is for everything else
        if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
          // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
        } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
          args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
        }

        // flatten out arrays that are arguments, to make the syntax:
        //    `cp([file1, file2, file3], dest);`
        // equivalent to:
        //    `cp(file1, file2, file3, dest);`
        args = args.reduce(function (accum, cur) {
          if (Array.isArray(cur)) {
            return accum.concat(cur);
          }
          accum.push(cur);
          return accum;
        }, []);

        // Convert ShellStrings (basically just String objects) to regular strings
        args = args.map(function (arg) {
          if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
            return arg.toString();
          }
          return arg;
        });

        // Expand the &#x27;~&#x27; if appropriate
        var homeDir = getUserHome();
        args = args.map(function (arg) {
          if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
            return arg.replace(/^~/, homeDir);
          }
          return arg;
        });

        // Perform glob-expansion on all arguments after globStart, but preserve
        // the arguments before it (like regexes for sed and grep)
        if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
          args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
        }

        try {
          // parse options if options are provided
          if (isObject(options.cmdOptions)) {
            args[0] = parseOptions(args[0], options.cmdOptions);
          }

          retValue = fn.apply(this, args);
        } catch (e) {
<span class="apidocCodeCommentSpan">          /* istanbul ignore else */
</span>          if (e.msg === &#x27;earlyExit&#x27;) {
            retValue = e.retValue;
          } else {
            throw e; // this is probably a bug that should be thrown up the call stack
          }
        }
      }
    } catch (e) {
      /* istanbul ignore next */
      if (!state.error) {
        // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
        console.error(&#x27;ShellJS: internal error&#x27;);
        console.error(e.stack || e);
        process.exit(1);
      }
      if (config.fatal) throw e;
    }

    if (options.wrapOutput &#x26;&#x26;
        (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
      retValue = new ShellString(retValue, state.error, state.errorCode);
    }

    state.currentCmd = &#x27;shell.js&#x27;;
    return retValue;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var shell = require(&#x27;./shell.js&#x27;);
var common = require(&#x27;./src/common&#x27;);
Object.keys(shell).forEach(function (cmd) {
  global[cmd] = shell[cmd];
});

var _to = require(&#x27;./src/to&#x27;);
String.prototype.to = common.<span class="apidocCodeKeywordSpan">wrap</span>(&#x27;to&#x27;, _to);

var _toEnd = require(&#x27;./src/toEnd&#x27;);
String.prototype.toEnd = common.wrap(&#x27;toEnd&#x27;, _toEnd);
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.shelljs.config" id="apidoc.module.shelljs.config">module shelljs.config</a></h1>










    <h2>
        <a href="#apidoc.element.shelljs.config.reset" id="apidoc.element.shelljs.config.reset">
        function <span class="apidocSignatureSpan">shelljs.config.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
  objectAssign(this, DEFAULT_CONFIG);
  if (!isElectron) {
    this.execPath = process.execPath;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
config.globOptions = {nodir: true};
```

Use this value for calls to `glob.sync()` instead of the default options.

### config.<span class="apidocCodeKeywordSpan">reset</span>()

Example:

```javascript
var shell = require(&#x27;shelljs&#x27;);
// Make changes to shell.config, and do stuff...
/* ... */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.config.resetForTesting" id="apidoc.element.shelljs.config.resetForTesting">
        function <span class="apidocSignatureSpan">shelljs.config.</span>resetForTesting
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resetForTesting = function () {
  this.reset();
  this.silent = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.shelljs.dirs" id="apidoc.module.shelljs.dirs">module shelljs.dirs</a></h1>


    <h2>
        <a href="#apidoc.element.shelljs.dirs.dirs" id="apidoc.element.shelljs.dirs.dirs">
        function <span class="apidocSignatureSpan">shelljs.</span>dirs
        <span class="apidocSignatureSpan">(options, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _dirs(options, index) {
  if (_isStackIndex(options)) {
    index = options;
    options = &#x27;&#x27;;
  }

  options = common.parseOptions(options, {
    &#x27;c&#x27;: &#x27;clear&#x27;,
  });

  if (options.clear) {
    _dirStack = [];
    return _dirStack;
  }

  var stack = _actualDirStack();

  if (index) {
    index = _parseStackIndex(index);

    if (index &#x3c; 0) {
      index = stack.length + index;
    }

    common.log(stack[index]);
    return stack[index];
  }

  common.log(stack.join(&#x27; &#x27;));

  return stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.dirs.popd" id="apidoc.element.shelljs.dirs.popd">
        function <span class="apidocSignatureSpan">shelljs.dirs.</span>popd
        <span class="apidocSignatureSpan">(options, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _popd(options, index) {
  if (_isStackIndex(options)) {
    index = options;
    options = &#x27;&#x27;;
  }

  options = common.parseOptions(options, {
    &#x27;n&#x27;: &#x27;no-cd&#x27;,
  });

  if (!_dirStack.length) {
    return common.error(&#x27;directory stack empty&#x27;);
  }

  index = _parseStackIndex(index || &#x27;+0&#x27;);

  if (options[&#x27;no-cd&#x27;] || index &#x3e; 0 || _dirStack.length + index === 0) {
    index = index &#x3e; 0 ? index - 1 : index;
    _dirStack.splice(index, 1);
  } else {
    var dir = path.resolve(_dirStack.shift());
    _cd(&#x27;&#x27;, dir);
  }

  return _dirs(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.dirs.pushd" id="apidoc.element.shelljs.dirs.pushd">
        function <span class="apidocSignatureSpan">shelljs.dirs.</span>pushd
        <span class="apidocSignatureSpan">(options, dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _pushd(options, dir) {
  if (_isStackIndex(options)) {
    dir = options;
    options = &#x27;&#x27;;
  }

  options = common.parseOptions(options, {
    &#x27;n&#x27;: &#x27;no-cd&#x27;,
  });

  var dirs = _actualDirStack();

  if (dir === &#x27;+0&#x27;) {
    return dirs; // +0 is a noop
  } else if (!dir) {
    if (dirs.length &#x3e; 1) {
      dirs = dirs.splice(1, 1).concat(dirs);
    } else {
      return common.error(&#x27;no other directory&#x27;);
    }
  } else if (_isStackIndex(dir)) {
    var n = _parseStackIndex(dir);
    dirs = dirs.slice(n).concat(dirs.slice(0, n));
  } else {
    if (options[&#x27;no-cd&#x27;]) {
      dirs.splice(1, 0, dir);
    } else {
      dirs.unshift(dir);
    }
  }

  if (options[&#x27;no-cd&#x27;]) {
    dirs = dirs.slice(1);
  } else {
    dir = path.resolve(dirs.shift());
    _cd(&#x27;&#x27;, dir);
  }

  _dirStack = dirs;
  return _dirs(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.shelljs.plugin" id="apidoc.module.shelljs.plugin">module shelljs.plugin</a></h1>


    <h2>
        <a href="#apidoc.element.shelljs.plugin.error" id="apidoc.element.shelljs.plugin.error">
        function <span class="apidocSignatureSpan">shelljs.plugin.</span>error
        <span class="apidocSignatureSpan">(msg, _code, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function error(msg, _code, options) {
  // Validate input
  if (typeof msg !== &#x27;string&#x27;) throw new Error(&#x27;msg must be a string&#x27;);

  var DEFAULT_OPTIONS = {
    continue: false,
    code: 1,
    prefix: state.currentCmd + &#x27;: &#x27;,
    silent: false,
  };

  if (typeof _code === &#x27;number&#x27; &#x26;&#x26; isObject(options)) {
    options.code = _code;
  } else if (isObject(_code)) { // no &#x27;code&#x27;
    options = _code;
  } else if (typeof _code === &#x27;number&#x27;) { // no &#x27;options&#x27;
    options = { code: _code };
  } else if (typeof _code !== &#x27;number&#x27;) { // only &#x27;msg&#x27;
    options = {};
  }
  options = objectAssign({}, DEFAULT_OPTIONS, options);

  if (!state.errorCode) state.errorCode = options.code;

  var logEntry = convertErrorOutput(options.prefix + msg);
  state.error = state.error ? state.error + &#x27;\n&#x27; : &#x27;&#x27;;
  state.error += logEntry;

  // Throw an error, or log the entry
  if (config.fatal) throw new Error(logEntry);
  if (msg.length &#x3e; 0 &#x26;&#x26; !options.silent) log(logEntry);

  if (!options.continue) {
    throw {
      msg: &#x27;earlyExit&#x27;,
      retValue: (new ShellString(&#x27;&#x27;, state.error, state.errorCode)),
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//@
//@ Returns a string containing the given file, or a concatenated string
//@ containing the files if more than one file is given (a new line character is
//@ introduced between each file).
function _cat(options, files) {
var cat = common.readFromPipe();

if (!files &#x26;&#x26; !cat) common.<span class="apidocCodeKeywordSpan">error</span>(&#x27;no paths given&#x27;);

files = [].slice.call(arguments, 1);

files.forEach(function (file) {
  if (!fs.existsSync(file)) {
    common.error(&#x27;no such file or directory: &#x27; + file);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.plugin.parseOptions" id="apidoc.element.shelljs.plugin.parseOptions">
        function <span class="apidocSignatureSpan">shelljs.plugin.</span>parseOptions
        <span class="apidocSignatureSpan">(opt, map, errorOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseOptions(opt, map, errorOptions) {
  // Validate input
  if (typeof opt !== &#x27;string&#x27; &#x26;&#x26; !isObject(opt)) {
    throw new Error(&#x27;options must be strings or key-value pairs&#x27;);
  } else if (!isObject(map)) {
    throw new Error(&#x27;parseOptions() internal error: map must be an object&#x27;);
  } else if (errorOptions &#x26;&#x26; !isObject(errorOptions)) {
    throw new Error(&#x27;parseOptions() internal error: errorOptions must be object&#x27;);
  }

  // All options are false by default
  var options = {};
  Object.keys(map).forEach(function (letter) {
    var optName = map[letter];
    if (optName[0] !== &#x27;!&#x27;) {
      options[optName] = false;
    }
  });

  if (opt === &#x27;&#x27;) return options; // defaults

  if (typeof opt === &#x27;string&#x27;) {
    if (opt[0] !== &#x27;-&#x27;) {
      error(&#x22;Options string must start with a &#x27;-&#x27;&#x22;, errorOptions || {});
    }

    // e.g. chars = [&#x27;R&#x27;, &#x27;f&#x27;]
    var chars = opt.slice(1).split(&#x27;&#x27;);

    chars.forEach(function (c) {
      if (c in map) {
        var optionName = map[c];
        if (optionName[0] === &#x27;!&#x27;) {
          options[optionName.slice(1)] = false;
        } else {
          options[optionName] = true;
        }
      } else {
        error(&#x27;option not recognized: &#x27; + c, errorOptions || {});
      }
    });
  } else { // opt is an Object
    Object.keys(opt).forEach(function (key) {
      // key is a string of the form &#x27;-r&#x27;, &#x27;-d&#x27;, etc.
      var c = key[1];
      if (c in map) {
        var optionName = map[c];
        options[optionName] = opt[key]; // assign the given value
      } else {
        error(&#x27;option not recognized: &#x27; + c, errorOptions || {});
      }
    });
  }
  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // If we are down by one argument and options starts with -, shift everything over.
    [].unshift.call(arguments, &#x27;&#x27;);
  } else {
    common.error(&#x27;You must specify a file.&#x27;);
  }
}

options = common.<span class="apidocCodeKeywordSpan">parseOptions</span>(options, {
  &#x27;R&#x27;: &#x27;recursive&#x27;,
  &#x27;c&#x27;: &#x27;changes&#x27;,
  &#x27;v&#x27;: &#x27;verbose&#x27;,
});

filePattern = [].slice.call(arguments, 2);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.plugin.readFromPipe" id="apidoc.element.shelljs.plugin.readFromPipe">
        function <span class="apidocSignatureSpan">shelljs.plugin.</span>readFromPipe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _readFromPipe() {
  return state.pipedValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//@ var str = cat([&#x27;file1&#x27;, &#x27;file2&#x27;]); // same as above
//@ ```
//@
//@ Returns a string containing the given file, or a concatenated string
//@ containing the files if more than one file is given (a new line character is
//@ introduced between each file).
function _cat(options, files) {
var cat = common.<span class="apidocCodeKeywordSpan">readFromPipe</span>();

if (!files &#x26;&#x26; !cat) common.error(&#x27;no paths given&#x27;);

files = [].slice.call(arguments, 1);

files.forEach(function (file) {
  if (!fs.existsSync(file)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.plugin.register" id="apidoc.element.shelljs.plugin.register">
        function <span class="apidocSignatureSpan">shelljs.plugin.</span>register
        <span class="apidocSignatureSpan">(name, implementation, wrapOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _register(name, implementation, wrapOptions) {
  wrapOptions = wrapOptions || {};
  // If an option isn&#x27;t specified, use the default
  wrapOptions = objectAssign({}, DEFAULT_WRAP_OPTIONS, wrapOptions);

  if (shell[name] &#x26;&#x26; !wrapOptions.overWrite) {
    throw new Error(&#x27;unable to overwrite `&#x27; + name + &#x27;` command&#x27;);
  }

  if (wrapOptions.pipeOnly) {
    wrapOptions.canReceivePipe = true;
    shellMethods[name] = wrap(name, implementation, wrapOptions);
  } else {
    shell[name] = wrap(name, implementation, wrapOptions);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...




var common = require(&#x27;./common&#x27;);
var fs = require(&#x27;fs&#x27;);

common.<span class="apidocCodeKeywordSpan">register</span>(&#x27;cat&#x27;, _cat, {
  canReceivePipe: true,
});

//@
//@ ### cat(file [, file ...])
//@ ### cat(file_array)
//@
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.shelljs.shell" id="apidoc.module.shelljs.shell">module shelljs.shell</a></h1>


    <h2>
        <a href="#apidoc.element.shelljs.shell.ShellString" id="apidoc.element.shelljs.shell.ShellString">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>ShellString
        <span class="apidocSignatureSpan">(stdout, stderr, code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ShellString(stdout, stderr, code) {
  var that;
  if (stdout instanceof Array) {
    that = stdout;
    that.stdout = stdout.join(&#x27;\n&#x27;);
    if (stdout.length &#x3e; 0) that.stdout += &#x27;\n&#x27;;
  } else {
    that = new String(stdout);
    that.stdout = stdout;
  }
  that.stderr = stderr;
  that.code = code;
  // A list of all commands that can appear on the right-hand side of a pipe
  // (populated by calls to common.wrap())
  pipeMethods.forEach(function (cmd) {
    that[cmd] = shellMethods[cmd].bind(that);
  });
  return that;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Dest is not existing dir, but multiple sources given
if ((!destExists || !destStat.isDirectory()) &#x26;&#x26; sources.length &#x3e; 1) {
  common.error(&#x27;dest is not a directory (too many sources)&#x27;);
}

// Dest is an existing file, but -n is given
if (destExists &#x26;&#x26; destStat.isFile() &#x26;&#x26; options.no_force) {
  return new common.<span class="apidocCodeKeywordSpan">ShellString</span>(&#x27;&#x27;, &#x27;&#x27;, 0);
}

sources.forEach(function (src) {
  if (!fs.existsSync(src)) {
    common.error(&#x27;no such file or directory: &#x27; + src, { continue: true });
    return; // skip file
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.cat" id="apidoc.element.shelljs.shell.cat">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>cat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cat = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
shell.cd(&#x27;lib&#x27;);
shell.ls(&#x27;*.js&#x27;).forEach(function (file) {
shell.sed(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
shell.sed(&#x27;-i&#x27;, /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.<span class="apidocCodeKeywordSpan">cat</span>(&#x27;macro.js&#
x27;), file);
});
shell.cd(&#x27;..&#x27;);

// Run external tool synchronously
if (shell.exec(&#x27;git commit -am &#x22;Auto-commit&#x22;&#x27;).code !== 0) {
shell.echo(&#x27;Error: Git commit failed&#x27;);
shell.exit(1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.cd" id="apidoc.element.shelljs.shell.cd">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>cd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cd = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
shell.<span class="apidocCodeKeywordSpan">cd</span>(&#x27;lib&#x27;);
shell.ls(&#x27;*.js&#x27;).forEach(function (file) {
  shell.sed(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat(&#x27;macro.js&#x27;), file);
});
shell.cd(&#x27;..&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.chmod" id="apidoc.element.shelljs.shell.chmod">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>chmod
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chmod = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.cp" id="apidoc.element.shelljs.shell.cp">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>cp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cp = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!shell.which(&#x27;git&#x27;)) {
shell.echo(&#x27;Sorry, this script requires git&#x27;);
shell.exit(1);
}

// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.<span class="apidocCodeKeywordSpan">cp</span>(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
shell.cd(&#x27;lib&#x27;);
shell.ls(&#x27;*.js&#x27;).forEach(function (file) {
shell.sed(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
shell.sed(&#x27;-i&#x27;, /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat(&#x27;macro.js&#x27;), file);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.dirs" id="apidoc.element.shelljs.shell.dirs">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>dirs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dirs = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.echo" id="apidoc.element.shelljs.shell.echo">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>echo
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">echo = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Examples

```javascript
var shell = require(&#x27;shelljs&#x27;);

if (!shell.which(&#x27;git&#x27;)) {
  shell.<span class="apidocCodeKeywordSpan">echo</span>(&#x27;Sorry, this script requires git&#x27;);
  shell.exit(1);
}

// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.error" id="apidoc.element.shelljs.shell.error">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>error
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function error() {
  return common.state.error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//@
//@ Returns a string containing the given file, or a concatenated string
//@ containing the files if more than one file is given (a new line character is
//@ introduced between each file).
function _cat(options, files) {
var cat = common.readFromPipe();

if (!files &#x26;&#x26; !cat) common.<span class="apidocCodeKeywordSpan">error</span>(&#x27;no paths given&#x27;);

files = [].slice.call(arguments, 1);

files.forEach(function (file) {
  if (!fs.existsSync(file)) {
    common.error(&#x27;no such file or directory: &#x27; + file);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.exec" id="apidoc.element.shelljs.shell.exec">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>exec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  shell.sed(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat(&#x27;macro.js&#x27;), file);
});
shell.cd(&#x27;..&#x27;);

// Run external tool synchronously
if (shell.<span class="apidocCodeKeywordSpan">exec</span>(&#x27;git commit -am &#x22;Auto-commit&#x22;&#x27;).code !== 0) {
  shell.echo(&#x27;Error: Git commit failed&#x27;);
  shell.exit(1);
}
```

## Global vs. Local
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.exit" id="apidoc.element.shelljs.shell.exit">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>exit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exit = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Examples

```javascript
var shell = require(&#x27;shelljs&#x27;);

if (!shell.which(&#x27;git&#x27;)) {
  shell.echo(&#x27;Sorry, this script requires git&#x27;);
  shell.<span class="apidocCodeKeywordSpan">exit</span>(1);
}

// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.find" id="apidoc.element.shelljs.shell.find">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>find
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.grep" id="apidoc.element.shelljs.shell.grep">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>grep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">grep = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### Pipes

Examples:

```javascript
grep(&#x27;foo&#x27;, &#x27;file1.txt&#x27;, &#x27;file2.txt&#x27;).sed(/o/g, &#x27;a&#x27;).to(&#x27;output.txt&#x27;);
echo(&#x27;files with o\&#x27;s in the name:\n&#x27; + ls().<span class="apidocCodeKeywordSpan">grep</span>(&#x27;o&#x27;));
cat(&#x27;test.js&#x27;).exec(&#x27;node&#x27;); // pipe to exec() call
```

Commands can send their output to another command in a pipe-like fashion.
`sed`, `grep`, `cat`, `exec`, `to`, and `toEnd` can appear on the right-hand
side of a pipe. Pipes can be chained.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.head" id="apidoc.element.shelljs.shell.head">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>head
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">head = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.ln" id="apidoc.element.shelljs.shell.ln">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>ln
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ln = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.ls" id="apidoc.element.shelljs.shell.ls">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>ls
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ls = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
shell.cd(&#x27;lib&#x27;);
shell.<span class="apidocCodeKeywordSpan">ls</span>(&#x27;*.js&#x27;).forEach(function (file) {
  shell.sed(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat(&#x27;macro.js&#x27;), file);
});
shell.cd(&#x27;..&#x27;);

// Run external tool synchronously
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.mkdir" id="apidoc.element.shelljs.shell.mkdir">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>mkdir
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdir = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.mv" id="apidoc.element.shelljs.shell.mv">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>mv
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mv = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.popd" id="apidoc.element.shelljs.shell.popd">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>popd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">popd = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.pushd" id="apidoc.element.shelljs.shell.pushd">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>pushd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pushd = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.pwd" id="apidoc.element.shelljs.shell.pwd">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>pwd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pwd = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.rm" id="apidoc.element.shelljs.shell.rm">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>rm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rm = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (!shell.which(&#x27;git&#x27;)) {
shell.echo(&#x27;Sorry, this script requires git&#x27;);
shell.exit(1);
}

// Copy files to release dir
shell.<span class="apidocCodeKeywordSpan">rm</span>(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
shell.cd(&#x27;lib&#x27;);
shell.ls(&#x27;*.js&#x27;).forEach(function (file) {
shell.sed(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.sed" id="apidoc.element.shelljs.shell.sed">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>sed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sed = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);

// Replace macros in each .js file
shell.cd(&#x27;lib&#x27;);
shell.ls(&#x27;*.js&#x27;).forEach(function (file) {
  shell.<span class="apidocCodeKeywordSpan">sed</span>(&#x27;-i&#x27;, &#x27;BUILD_VERSION&#x27;, &#x27;v0.1.2&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /^.*REMOVE_THIS_LINE.*$/, &#x27;&#x27;, file);
  shell.sed(&#x27;-i&#x27;, /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat(&#x27;macro.js&#x27;), file);
});
shell.cd(&#x27;..&#x27;);

// Run external tool synchronously
if (shell.exec(&#x27;git commit -am &#x22;Auto-commit&#x22;&#x27;).code !== 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.set" id="apidoc.element.shelljs.shell.set">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.sort" id="apidoc.element.shelljs.shell.sort">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>sort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sort = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    var contents = file === &#x27;-&#x27; ? pipe : fs.readFileSync(file, &#x27;utf8&#x27;);
    lines = lines.concat(contents.trimRight().split(/\r*\n/));
  });

  var sorted;
  sorted = lines.<span class="apidocCodeKeywordSpan">sort</span>(options.numerical ? numericalCmp : unixCmp);

  if (options.reverse) {
    sorted = sorted.reverse();
  }

  return sorted.join(&#x27;\n&#x27;) + &#x27;\n&#x27;;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.tail" id="apidoc.element.shelljs.shell.tail">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>tail
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tail = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.tempdir" id="apidoc.element.shelljs.shell.tempdir">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>tempdir
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tempdir = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.test" id="apidoc.element.shelljs.shell.test">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>test
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">test = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    //   $ cd ../../../..
    //   $ cp -RL 1 copy
    var cyclecheck = fs.statSync(srcFile);
    if (cyclecheck.isDirectory()) {
      var sourcerealpath = fs.realpathSync(sourceDir);
      var symlinkrealpath = fs.realpathSync(srcFile);
      var re = new RegExp(symlinkrealpath);
      if (re.<span class="apidocCodeKeywordSpan">test</span>(sourcerealpath)) {
        return true;
      }
    }
  }
  return false;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.touch" id="apidoc.element.shelljs.shell.touch">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>touch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">touch = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.uniq" id="apidoc.element.shelljs.shell.uniq">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>uniq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uniq = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.shelljs.shell.which" id="apidoc.element.shelljs.shell.which">
        function <span class="apidocSignatureSpan">shelljs.shell.</span>which
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">which = function () {
  var retValue = null;

  state.currentCmd = cmd;
  state.error = null;
  state.errorCode = 0;

  try {
    var args = [].slice.call(arguments, 0);

    // Log the command to stderr, if appropriate
    if (config.verbose) {
      console.error.apply(console, [cmd].concat(args));
    }

    // If this is coming from a pipe, let&#x27;s set the pipedValue (otherwise, set
    // it to the empty string)
    state.pipedValue = (this &#x26;&#x26; typeof this.stdout === &#x27;string&#x27;) ? this.stdout : &#x27;&#x27;;

    if (options.unix === false) { // this branch is for exec()
      retValue = fn.apply(this, args);
    } else { // and this branch is for everything else
      if (isObject(args[0]) &#x26;&#x26; args[0].constructor.name === &#x27;Object&#x27;) {
        // a no-op, allowing the syntax `touch({&#x27;-r&#x27;: file}, ...)`
      } else if (args.length === 0 || typeof args[0] !== &#x27;string&#x27; || args[0].length &#x3c;= 1 || args[0][0] !== &#x27;-&#x27;) {
        args.unshift(&#x27;&#x27;); // only add dummy option if &#x27;-option&#x27; not already present
      }

      // flatten out arrays that are arguments, to make the syntax:
      //    `cp([file1, file2, file3], dest);`
      // equivalent to:
      //    `cp(file1, file2, file3, dest);`
      args = args.reduce(function (accum, cur) {
        if (Array.isArray(cur)) {
          return accum.concat(cur);
        }
        accum.push(cur);
        return accum;
      }, []);

      // Convert ShellStrings (basically just String objects) to regular strings
      args = args.map(function (arg) {
        if (isObject(arg) &#x26;&#x26; arg.constructor.name === &#x27;String&#x27;) {
          return arg.toString();
        }
        return arg;
      });

      // Expand the &#x27;~&#x27; if appropriate
      var homeDir = getUserHome();
      args = args.map(function (arg) {
        if (typeof arg === &#x27;string&#x27; &#x26;&#x26; arg.slice(0, 2) === &#x27;~/&#x27; || arg === &#x27;~&#x27;) {
          return arg.replace(/^~/, homeDir);
        }
        return arg;
      });

      // Perform glob-expansion on all arguments after globStart, but preserve
      // the arguments before it (like regexes for sed and grep)
      if (!config.noglob &#x26;&#x26; options.allowGlobbing === true) {
        args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
      }

      try {
        // parse options if options are provided
        if (isObject(options.cmdOptions)) {
          args[0] = parseOptions(args[0], options.cmdOptions);
        }

        retValue = fn.apply(this, args);
      } catch (e) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else */
</span>        if (e.msg === &#x27;earlyExit&#x27;) {
          retValue = e.retValue;
        } else {
          throw e; // this is probably a bug that should be thrown up the call stack
        }
      }
    }
  } catch (e) {
    /* istanbul ignore next */
    if (!state.error) {
      // If state.error hasn&#x27;t been set it&#x27;s an error thrown by Node, not us - probably a bug...
      console.error(&#x27;ShellJS: internal error&#x27;);
      console.error(e.stack || e);
      process.exit(1);
    }
    if (config.fatal) throw e;
  }

  if (options.wrapOutput &#x26;&#x26;
      (typeof retValue === &#x27;string&#x27; || Array.isArray(retValue))) {
    retValue = new ShellString(retValue, state.error, state.errorCode);
  }

  state.currentCmd = &#x27;shell.js&#x27;;
  return retValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

## Examples

```javascript
var shell = require(&#x27;shelljs&#x27;);

if (!shell.<span class="apidocCodeKeywordSpan">which</span>(&#x27;git&#x27;)) {
  shell.echo(&#x27;Sorry, this script requires git&#x27;);
  shell.exit(1);
}

// Copy files to release dir
shell.rm(&#x27;-rf&#x27;, &#x27;out/Release&#x27;);
shell.cp(&#x27;-R&#x27;, &#x27;stuff/&#x27;, &#x27;out/Release&#x27;);
...</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
